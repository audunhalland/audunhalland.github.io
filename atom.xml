<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>Audun Halland</title>
    <subtitle>My home on the internet</subtitle>
    <link href="https://audunhalland.github.io/atom.xml" rel="self" type="application/atom+xml"/>
    <link href="https://audunhalland.github.io"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2024-04-26T00:00:00+00:00</updated>
    <id>https://audunhalland.github.io/atom.xml</id>
    <entry xml:lang="en">
        <title>Unimock 0.6: Mutation patterns</title>
        <published>2024-04-26T00:00:00+00:00</published>
        <updated>2024-04-26T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://audunhalland.github.io/blog/unimock-0-6/" type="text/html"/>
        <id>https://audunhalland.github.io/blog/unimock-0-6/</id>
        
        <content type="html">&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;unimock&#x2F;0.6&#x2F;unimock&#x2F;index.html&quot;&gt;Unimock 0.6&lt;&#x2F;a&gt; is just out, with an important change in design which makes it much more powerful than before.&lt;&#x2F;p&gt;
&lt;p&gt;The previous version (0.5) added support for parameter mutation, but it was quite limited.
The reason for the limitation was an inferior design that took a significant amount of trial and error to finally fix.
In hindsight it might seem obvious, but for some reason it wasn&#x27;t to me.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;TL;DR&lt;&#x2F;em&gt;: Unimock&#x27;s &lt;code&gt;answers&lt;&#x2F;code&gt; API is now based on an associated type instantiated to a &lt;code&gt;dyn Fn&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;background&quot;&gt;Background&lt;&#x2F;h2&gt;
&lt;p&gt;Unimock allows developers to define flexible one-off verifiable trait implementations with very little code&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;unimock&lt;&#x2F;span&gt;&lt;span&gt;(api = SomeTraitMock)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;SomeTrait &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;my_func&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; u = Unimock::new(
&lt;&#x2F;span&gt;&lt;span&gt;    SomeTraitMock::my_func
&lt;&#x2F;span&gt;&lt;span&gt;        .next_call(matching!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;42&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;        .returns(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;assert_eq!(u.my_func(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;42&lt;&#x2F;span&gt;&lt;span&gt;), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It also supports invoking a user-supplied function to compute the output dynamically:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; u = Unimock::new(
&lt;&#x2F;span&gt;&lt;span&gt;    SomeTraitMock::my_func
&lt;&#x2F;span&gt;&lt;span&gt;        .next_call(matching!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;42&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;        .answers(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;| input * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; &amp;lt;-- note: The old 0.5 API
&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;assert_eq!(u.my_func(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;42&lt;&#x2F;span&gt;&lt;span&gt;), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;84&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;But a problem appeared when I wanted to provide a mock integration for e.g. &lt;code&gt;Display&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Display &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;fmt&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span&gt;Formatter&amp;lt;&amp;#39;_&amp;gt;) -&amp;gt; Result&amp;lt;(), Error&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;Display&lt;&#x2F;code&gt; implementors supply behaviour by interacting with the mutable parameter &lt;code&gt;f&lt;&#x2F;code&gt;.
The return value is only used for reporting errors, and can be considered secondary.&lt;&#x2F;p&gt;
&lt;p&gt;As soon as the &lt;code&gt;answers&lt;&#x2F;code&gt; function needed to mutate parameters, it ran into problems with the type system.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-old-0-5-model&quot;&gt;The old 0.5 model&lt;&#x2F;h2&gt;
&lt;p&gt;Unimock&#x27;s function model was loosely based on a trait like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;MockFn &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Inputs&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;i&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; &amp;#39;i = lifetime of borrowed values in an inputs tuple
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Output&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;u&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; &amp;#39;u = lifetime of output borrowed from Self
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Using this model, it is quite easy to define a function bound like &lt;code&gt;Fn(F::Inputs&amp;lt;&#x27;i&amp;gt;) -&amp;gt; F::Output&amp;lt;&#x27;u&amp;gt;&lt;&#x2F;code&gt;.
But as soon as mutation is involved, this signature is not going to cut it, because the set of involved lifetimes is not finite anymore.&lt;&#x2F;p&gt;
&lt;p&gt;Version 0.5 ended up using a hack where &lt;em&gt;one&lt;&#x2F;em&gt; parameter could be mutated.
That &lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt; parameter (if present) was excluded from the the &lt;code&gt;Inputs&amp;lt;&#x27;i&amp;gt;&lt;&#x2F;code&gt; tuple, and handled completely separately from all other inputs.
This meant that it wasn&#x27;t possible to use the &lt;code&gt;matching!&lt;&#x2F;code&gt;-macro on that parameter.
The &lt;code&gt;matching&lt;&#x2F;code&gt; macro operates on immutable views of the function inputs, where a single, common lifetime parameter cuts it (because matching only reads things and does not return anything).&lt;&#x2F;p&gt;
&lt;p&gt;Given these limitations it became clear that this wasn&#x27;t very &lt;em&gt;developer friendly&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;0-6-a-better-model-for-mutation-patterns&quot;&gt;0.6: A better model for mutation patterns&lt;&#x2F;h2&gt;
&lt;p&gt;After trying many experiments with several predefined possibly-used GAT-lifetimes, I was ready to give up after hitting Rust limitations like not being able to sepcify outlives-bounds involving higher-ranked lifetimes (&lt;code&gt;for&amp;lt;&#x27;a, &#x27;b&amp;gt; where &#x27;b: &#x27;a&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;Then it occured to me that it&#x27;s possible to take advantage of the compiler&#x27;s builtin syntax to express exactly what is needed using &lt;em&gt;implied bounds&lt;&#x2F;em&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;b&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; Fn(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;a i32&lt;&#x2F;span&gt;&lt;span&gt;, &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;b mut &lt;&#x2F;span&gt;&lt;span&gt;Foo&amp;lt;&amp;#39;_&amp;gt;) -&amp;gt; Bar&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;Fn&lt;&#x2F;code&gt; &lt;em&gt;syntax family&lt;&#x2F;em&gt; expresses this perfectly, but what the &lt;code&gt;MockFn&lt;&#x2F;code&gt; trait needs is an associated &lt;em&gt;type&lt;&#x2F;em&gt;, not another trait bound (the &lt;code&gt;MockFn&lt;&#x2F;code&gt; is implemented for different function signatures!).&lt;&#x2F;p&gt;
&lt;p&gt;The answer to that is to use &lt;code&gt;dyn Fn&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Display &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;fmt&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span&gt;Formatter&amp;lt;&amp;#39;_&amp;gt;) -&amp;gt; Result&amp;lt;(), Error&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; #[unimock]-generated code:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;mod &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;DisplayMock &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;fmt&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;MockFn for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;DisplayMock&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;fmt &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;AnswerFn &lt;&#x2F;span&gt;&lt;span&gt;= dyn (
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;u&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; Fn(
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;u &lt;&#x2F;span&gt;&lt;span&gt;crate::Unimock,
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span&gt;core::fmt::Formatter&amp;lt;&amp;#39;_&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;        ) -&amp;gt; core::fmt::Result
&lt;&#x2F;span&gt;&lt;span&gt;    ) + Send + Sync;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The upside is that all mutation patterns are now possible, but the downside is that &lt;code&gt;dyn Fn&lt;&#x2F;code&gt; is a type instead of a bound.&lt;&#x2F;p&gt;
&lt;p&gt;The unimock user has to supply a value of this type into the &lt;code&gt;answers&lt;&#x2F;code&gt; combinator:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; defined as:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;.. {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; note: F::AnswerFn (i.e. dyn Fn) must be an unsized type:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;answers&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;answer_fn&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;static F::&lt;&#x2F;span&gt;&lt;span&gt;AnswerFn) { .. }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; u = Unimock::new(
&lt;&#x2F;span&gt;&lt;span&gt;    DisplayMock::fmt
&lt;&#x2F;span&gt;&lt;span&gt;        .next_call(matching!(_))
&lt;&#x2F;span&gt;&lt;span&gt;        .answers(&amp;amp;|_, f| write!(f, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;mocked!&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This forces the user to pass a function reference rather than any closure that just happens to implement a given &lt;code&gt;Fn&lt;&#x2F;code&gt; signature like it did before.&lt;&#x2F;p&gt;
&lt;p&gt;Closure patterns are possible, and unimock supports this, but not in a generic way.
Closures have to be passed using a different combinator:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;.. {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; must take an Arc, because userland functions
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; can&amp;#39;t accept unsized types:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;answers_arc&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;answer_fn&lt;&#x2F;span&gt;&lt;span&gt;: Arc&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;F::&lt;&#x2F;span&gt;&lt;span&gt;AnswerFn&amp;gt;) { .. }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I of course tried to make an abstraction that unites the two APIs, but failed to do so.
I believe the reason for this is that &lt;em&gt;dyn trait coercion&lt;&#x2F;em&gt; can&#x27;t be abstracted.&lt;&#x2F;p&gt;
&lt;h5 id=&quot;footnotes&quot;&gt;Footnotes&lt;&#x2F;h5&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;For even more background, and a walk-through of Unimock&#x27;s overall design: &lt;a href=&quot;https:&#x2F;&#x2F;audunhalland.github.io&#x2F;blog&#x2F;how-to-write-a-type-level-mock-library-in-rust&#x2F;&quot;&gt;How to write a type-level mock library in Rust&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>How to write a type-level mock library in Rust</title>
        <published>2023-04-11T00:00:00+00:00</published>
        <updated>2023-04-11T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://audunhalland.github.io/blog/how-to-write-a-type-level-mock-library-in-rust/" type="text/html"/>
        <id>https://audunhalland.github.io/blog/how-to-write-a-type-level-mock-library-in-rust/</id>
        
        <content type="html">&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;unimock&#x2F;latest&#x2F;unimock&#x2F;&quot;&gt;Unimock 0.5&lt;&#x2F;a&gt; is just out, and I wanted to reflect on how it came to be, how its design emerged and various implementation challenges along the way.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;why-unimock-exists&quot;&gt;Why unimock exists&lt;&#x2F;h2&gt;
&lt;p&gt;Rust already has a number of mocking solutions, like the popular &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;mockall&#x2F;latest&#x2F;mockall&#x2F;&quot;&gt;mockall&lt;&#x2F;a&gt;. Why another one?&lt;&#x2F;p&gt;
&lt;p&gt;The idea behind unimock comes from the observation that Rust traits form some kind of graph:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; There is a supertrait relationship between Foo and Bar:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Foo&lt;&#x2F;span&gt;&lt;span&gt;: Bar {}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;A &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;B &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; A and B are related via the fact that some type T needs to implement both:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;func&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;t&lt;&#x2F;span&gt;&lt;span&gt;: T) where T: A + B {}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To be maximally flexible, a trait mocking library needs to support all combinations of trait bounds.
If we wanted to write a test implementation of &lt;code&gt;Foo&lt;&#x2F;code&gt;, we&#x27;d also have to write one for &lt;code&gt;Bar&lt;&#x2F;code&gt;.
If we want to test &lt;code&gt;func&lt;&#x2F;code&gt;, the test type needs to implement both &lt;code&gt;A&lt;&#x2F;code&gt; and &lt;code&gt;B&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Ultimately, there is only one possibility: All the traits need to be implemented by &lt;em&gt;the same type&lt;&#x2F;em&gt;!&lt;&#x2F;p&gt;
&lt;p&gt;This challenge first appeared while I experimented with &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;entrait&#x2F;latest&#x2F;entrait&#x2F;&quot;&gt;entrait&lt;&#x2F;a&gt;, which is entirely made up of a trait graph.
I quickly hit a road block when trying to use &lt;code&gt;mockall&lt;&#x2F;code&gt; as a test tool, because it uses one type per mocked trait.
The next sections are modelled as a walkthrough on how a universal Unimock-like mocker can be (and is!) implemented, and some of the design challenges are discussed.&lt;&#x2F;p&gt;
&lt;p&gt;By &lt;em&gt;&amp;quot;type-level&amp;quot; mocker&lt;&#x2F;em&gt;, I mean a library that relies more on generics, traits and bounds than lots of macro-generated custom code blocks.
Unimock, although it comes with a fairly complex procedural macro that does trait parsing and analysis, is a type-level mocker.
The macro&#x27;s job is to figure out what types to define!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;implementing-a-simple-mocker-from-scratch&quot;&gt;Implementing a simple mocker from scratch&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s start with a simple trait.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Foo &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We&#x27;d like to mock it! We want to start out with a type that can return a configurable &lt;code&gt;i32&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Mocker&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Foo for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Mocker &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We&#x27;ve created a simple mock library!
But now let&#x27;s reuse that type for another trait:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Bar &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;bar&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; String;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now the &lt;code&gt;Mocker&lt;&#x2F;code&gt; needs two fields: An &lt;code&gt;i32&lt;&#x2F;code&gt; and a &lt;code&gt;String&lt;&#x2F;code&gt;.
Going on like this can&#x27;t scale forever, so we need to look at some more dynamic solutions.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Mocker &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;return_values&lt;&#x2F;span&gt;&lt;span&gt;: HashMap&amp;lt;TypeId, Box&amp;lt;dyn Any&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Foo for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Mocker &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; ret = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.return_values.get(&amp;amp;TypeId::of::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;()).unwrap();
&lt;&#x2F;span&gt;&lt;span&gt;        ret.downcast_ref::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;().unwrap().clone()
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This looks more dynamic and using &lt;code&gt;Any&lt;&#x2F;code&gt; and &lt;code&gt;TypeId&lt;&#x2F;code&gt; seems like a good idea, but there are two problems:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;All methods that return &lt;code&gt;i32&lt;&#x2F;code&gt; has to return the same value.&lt;&#x2F;li&gt;
&lt;li&gt;All return types need to be &lt;code&gt;&#x27;static&lt;&#x2F;code&gt; in order to implement &lt;code&gt;Any&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;We have to be able to control each trait method individually from any other trait method.
Rust trait methods are not types, and cannot implement any traits (i.e. &lt;code&gt;Any&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;This can be solved by defining a new type per method:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; module which represents the trait
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;mod &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;FooMock &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; struct which represents the method
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And defining each method&#x27;s return type through a new trait with an associated type:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; &amp;#39;static makes this automatically implement Any
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;MockFn&lt;&#x2F;span&gt;&lt;span&gt;: &amp;#39;static {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Output&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;MockFn for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;FooMock&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;foo &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Mocker &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;return_values&lt;&#x2F;span&gt;&lt;span&gt;: HashMap&amp;lt;TypeId, Box&amp;lt;dyn Any&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Foo for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Mocker &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; return_value = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self
&lt;&#x2F;span&gt;&lt;span&gt;            .return_values
&lt;&#x2F;span&gt;&lt;span&gt;            .get(&amp;amp;TypeId::of::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;FooMock::&lt;&#x2F;span&gt;&lt;span&gt;foo&amp;gt;())
&lt;&#x2F;span&gt;&lt;span&gt;            .unwrap();
&lt;&#x2F;span&gt;&lt;span&gt;        return_value.downcast_ref::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;().unwrap().clone()
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;What&#x27;s the point of the &lt;code&gt;Output&lt;&#x2F;code&gt; associated type? It&#x27;s not used at all in &lt;code&gt;impl Foo for Mocker&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Before the mocker can be used, the user needs to specify which return values each method will have.
It would not be a very good idea if the interface to configure the mocker exposed &lt;code&gt;Box&amp;lt;dyn Any&amp;gt;&lt;&#x2F;code&gt;.
So we&#x27;ll design the configuration API around this associated type, and box the return value internally:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Mocker &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;should_return&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;F: MockFn&amp;gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;value&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;F::&lt;&#x2F;span&gt;&lt;span&gt;Output)
&lt;&#x2F;span&gt;&lt;span&gt;        where &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;F::&lt;&#x2F;span&gt;&lt;span&gt;Output: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;static
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.return_values.insert(TypeId::of::&amp;lt;F&amp;gt;(), Box::new(value));
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we have implemented two phases of the mocking lifecycle: &lt;em&gt;Configuration&lt;&#x2F;em&gt; and &lt;em&gt;interaction&lt;&#x2F;em&gt;.
The two phases are galvanically isolated but still type safe by the use of &lt;code&gt;dyn Any&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;There is still a problem that return values must be &lt;code&gt;&#x27;static&lt;&#x2F;code&gt;.
This can be solved by using an internal &lt;code&gt;enum&lt;&#x2F;code&gt; with two variants:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;A &lt;code&gt;Box&amp;lt;Any&amp;gt;&lt;&#x2F;code&gt; representing a &lt;code&gt;&#x27;static&lt;&#x2F;code&gt; return value&lt;&#x2F;li&gt;
&lt;li&gt;A &lt;code&gt;Box&amp;lt;Any&amp;gt;&lt;&#x2F;code&gt; representing a &lt;em&gt;static closure&lt;&#x2F;em&gt; that returns &lt;code&gt;F::Output&lt;&#x2F;code&gt; directly (and postpone the problem with what it actually references with its non-static lifetime).&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;returning-references&quot;&gt;Returning references&lt;&#x2F;h3&gt;
&lt;p&gt;The return values currently supported are owned types, including &lt;code&gt;&amp;amp;&#x27;static T&lt;&#x2F;code&gt;.
There is no way to put non-static references into that hash map.&lt;&#x2F;p&gt;
&lt;p&gt;What kind of references could we expect to support?
The archetypal pattern is likely some variation of this with the elided self-lifetime:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Foo &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;str&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To support this, the mocker has to store an owned version of the return value and return a reference to it.
This already indicates that the configuration and interaction phases do not necessarily use the same types.
We could configure the mocker with a &lt;code&gt;String&lt;&#x2F;code&gt; and then return a &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; of it later.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;MockFn &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Output&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Response&lt;&#x2F;span&gt;&lt;span&gt;: AsRef&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is a start, but now &lt;em&gt;all&lt;&#x2F;em&gt; outputs must be references of the response, that is not what we wanted.
What we need is a way to tell the mocker the &amp;quot;general category&amp;quot; of output: Owned or Borrowed.
Let&#x27;s introduce a new trait:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Respond &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Type&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;Type&lt;&#x2F;code&gt; is the owned version of the type that is allowed to be stored in the hash map.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Owned&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt;(PhantomData&amp;lt;T&amp;gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Borrowed&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T: ?Sized + &amp;#39;static&amp;gt;(PhantomData&amp;lt;T&amp;gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;These are the two current variants.
To wire things up, we need yet another trait:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Output&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&amp;#39;a, R: Respond&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Type&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;from_response&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;response&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;R::&lt;&#x2F;span&gt;&lt;span&gt;Type) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Type;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let&#x27;s start by implementing &lt;code&gt;Owned&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; Respond for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Owned&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Type &lt;&#x2F;span&gt;&lt;span&gt;= T;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;, T: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; Output&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Owned&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Type &lt;&#x2F;span&gt;&lt;span&gt;= T;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;from_response&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;response&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;R::&lt;&#x2F;span&gt;&lt;span&gt;Type) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Type {
&lt;&#x2F;span&gt;&lt;span&gt;        response
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;These implementations express that an &lt;code&gt;Output::Type&lt;&#x2F;code&gt; is an &amp;quot;identity transformation&amp;quot; from &lt;code&gt;Respond::Type&lt;&#x2F;code&gt; in the case of &lt;code&gt;Owned&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;.
Notice the &lt;code&gt;&#x27;a&lt;&#x2F;code&gt; lifetime introduced in the &lt;code&gt;Output&lt;&#x2F;code&gt; trait.
This lifetime represents borrowing from the mocker, and we will need it when implementing &lt;code&gt;Borrowed&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;But first, we have to change &lt;code&gt;MockFn&lt;&#x2F;code&gt; to use our new traits, and now we&#x27;ll need a Generic Associated Type:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;MockFn &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Response&lt;&#x2F;span&gt;&lt;span&gt;: Respond;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Output&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;: Output&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Response&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The bounds on these types illustrate how &lt;code&gt;Response&lt;&#x2F;code&gt; and &lt;code&gt;Output&lt;&#x2F;code&gt; are connected.
The output must be an Output that can be constructed from the response, and the output is allowed to be a reference.&lt;&#x2F;p&gt;
&lt;p&gt;Now over to &lt;code&gt;Borrowed&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T: ?&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Sized&lt;&#x2F;span&gt;&lt;span&gt; + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Respond for Borrowed&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Type &lt;&#x2F;span&gt;&lt;span&gt;= Box&amp;lt;dyn std::borrow::Borrow&amp;lt;T&amp;gt; + Send + Sync&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The type stored in the hash map is any type from which we can &lt;code&gt;Borrow&lt;&#x2F;code&gt; a &lt;code&gt;T&lt;&#x2F;code&gt;.
For example, &lt;code&gt;String&lt;&#x2F;code&gt; in the case of &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt;. (If we want &lt;code&gt;Mocker&lt;&#x2F;code&gt; to be thread safe we need Send and Sync bounds.)&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;, T: ?&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Sized&lt;&#x2F;span&gt;&lt;span&gt; + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Output&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;for Borrowed&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Type &lt;&#x2F;span&gt;&lt;span&gt;= &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt; T;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;from_response&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;response&lt;&#x2F;span&gt;&lt;span&gt;: &amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;as Respond&amp;gt;::Type,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Type {
&lt;&#x2F;span&gt;&lt;span&gt;        panic!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;Dang, cannot return borrow of a local&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here is the next spanner in the works.
We want to borrow the &lt;code&gt;Respond::Type&lt;&#x2F;code&gt;, but can&#x27;t, since it is being passed by-value into the &lt;code&gt;from_response&lt;&#x2F;code&gt; function.
Now you might object that the &lt;code&gt;from_response&lt;&#x2F;code&gt; design is wrong.
Why is it passed an owned response when it could just borrow directly from the mocker&#x27;s hash table?
Some paragraphs ago we said that the hash table can contain one of two things: An owned response and a closure that produces an owned response.
So we need to handle the ephemeral owned response anyway: Yes, returning a reference to something just produced by a function.&lt;&#x2F;p&gt;
&lt;p&gt;Finding a (safe) solution to this problem was not easy.
I needed some kind of data structure that can convert &lt;code&gt;T&lt;&#x2F;code&gt;&#x27;s to &lt;code&gt;&amp;amp;&#x27;self T&lt;&#x2F;code&gt;&#x27;s.
It needs to use interior mutability, or else we can&#x27;t get &lt;code&gt;&amp;amp;T&lt;&#x2F;code&gt;&#x27;s out.
Once a &lt;code&gt;T&lt;&#x2F;code&gt; has been added to the structure, that &lt;code&gt;T&lt;&#x2F;code&gt; can&#x27;t ever be touched until &lt;code&gt;drop&lt;&#x2F;code&gt;, or else the &lt;code&gt;&amp;amp;T&lt;&#x2F;code&gt; would be invalid.
The end solution involves a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;once_cell&#x2F;latest&#x2F;once_cell&#x2F;&quot;&gt;once_cell&lt;&#x2F;a&gt; chain, the code can be found in the unimock repo.&lt;&#x2F;p&gt;
&lt;p&gt;In Unimock, there are even more variants of &lt;code&gt;Respond&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;Output&lt;&#x2F;code&gt;, the most notable one is called &lt;code&gt;Mixed&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;.
&lt;code&gt;Mixed&lt;&#x2F;code&gt; is used in Owned&#x2F;Borrowed tree-like situations, for example with the following signatures:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Foo &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;f1&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Option&amp;lt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;str&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;f2&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; (String, &amp;amp;String);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;observing-parameters&quot;&gt;Observing parameters&lt;&#x2F;h3&gt;
&lt;p&gt;So in addition to outputs, functions also have inputs.&lt;&#x2F;p&gt;
&lt;p&gt;In a typical mocking situation we want to test some code that calls into a trait.
The trait implementation would like to check that it receives some expected parameter value, and react accordingly.
&amp;quot;Reacting accordingly&amp;quot; is to be understood as &amp;quot;returning some specific output&amp;quot;.&lt;&#x2F;p&gt;
&lt;p&gt;This parameter observation business is also something that happens at interaction time, but is specified up front at configuration time.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s extend the &lt;code&gt;MockFn&lt;&#x2F;code&gt; trait with some inputs:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;MockFn &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Inputs&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;i&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; ..
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When the function has multiple inputs it will use a tuple.
The &lt;code&gt;&#x27;i&lt;&#x2F;code&gt; lifetime is quite handy.
As long as the parameters are immutable, the same lifetime can be used for all of them.
(&lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt; on the other hand, can not be modelled this way. I won&#x27;t get into this in this article, but it&#x27;s related to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;100013&quot;&gt;unexpected higher-ranked lifetime error in GAT usage&lt;&#x2F;a&gt;)&lt;&#x2F;p&gt;
&lt;p&gt;So, the mocker receives some &lt;code&gt;Inputs&lt;&#x2F;code&gt; and wants to produce an &lt;code&gt;Output&lt;&#x2F;code&gt;.
The user has to control which inputs map to which output.
It&#x27;s not possible to just put the inputs in any kind of table, because that would require trait bounds.
Instead the user needs to supply a function that receives a reference to the inputs, and returns whether it is a &amp;quot;match&amp;quot; or not.&lt;&#x2F;p&gt;
&lt;p&gt;Something like:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;|inputs| matches!(inputs, (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;3.0&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This closure type can be converted into to &lt;code&gt;Box&amp;lt;Any&amp;gt;&lt;&#x2F;code&gt; and stored together with the return values in the hash map.&lt;&#x2F;p&gt;
&lt;p&gt;Except, it&#x27;s not that easy.
This solution &amp;quot;works&amp;quot;, but is quite hard to debug when the user &lt;em&gt;expects&lt;&#x2F;em&gt; a match that for some reason doesn&#x27;t at runtime.
The mocker could panic with a message that it found no response for the given inputs, but it would be handy to see &lt;em&gt;why&lt;&#x2F;em&gt; there was a mismatch.
(In mocking terminology, a proper mock is something you &lt;em&gt;expect&lt;&#x2F;em&gt; to be called.
If it isn&#x27;t, that&#x27;s an error.)&lt;&#x2F;p&gt;
&lt;p&gt;Another annoying issue with the &lt;code&gt;matches!&lt;&#x2F;code&gt; approach is the lack of &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;87121&quot;&gt;Deref patterns&lt;&#x2F;a&gt;.
I.e. if one of the inputs is of type &lt;code&gt;String&lt;&#x2F;code&gt;, it can&#x27;t be matched with a &lt;code&gt;&amp;quot;string literal&amp;quot;&lt;&#x2F;code&gt;.
This is one of the most annoying missing features in Rust for me personally.
So what I wanted for Unimock was a higher level macro for input matching, that encapsulates the closue syntax (it produces a closure) and has some plumbing that works around some of the missing Deref patterns issues.&lt;&#x2F;p&gt;
&lt;p&gt;The macro is called &lt;code&gt;matching!&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;matching!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;3.0&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It basically expands to a pattern match on the arguments, along with useful diagnostics in the case of an unsuccessful match.
Every string literal is matched using &lt;code&gt;AsRef&amp;lt;str&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The input matching was not the hardest part to design.
Now let&#x27;s move to the part that is most visible to users.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-configuration-phase&quot;&gt;The configuration phase&lt;&#x2F;h2&gt;
&lt;p&gt;The configuration phase is what happens first (at the top of the test) and really ties all the parts toghether.
It&#x27;s also the API that users have to suffer through actually using, API ergonomics should be in the front seat!&lt;&#x2F;p&gt;
&lt;p&gt;First some general observations about the mock configuration phase.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The mocker is either configured or it&#x27;s not configured.
This implies some kind of builder pattern, where you are either in the configuration phase or interaction phase, enforced by type state.&lt;&#x2F;li&gt;
&lt;li&gt;People like to write reusable code. It should be easy to factor out parts of the configuration phase to be reused many times.&lt;&#x2F;li&gt;
&lt;li&gt;It should not be too verbose.&lt;&#x2F;li&gt;
&lt;li&gt;It should not be too cryptic.&lt;&#x2F;li&gt;
&lt;li&gt;Not too much &lt;code&gt;rustfmt&lt;&#x2F;code&gt; indentation whitespace.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;rustfmt&lt;&#x2F;code&gt; indentation should visually group things in a logical way.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Let&#x27;s start with a &lt;code&gt;MockBuilder&lt;&#x2F;code&gt; first:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;MockBuilder::new()
&lt;&#x2F;span&gt;&lt;span&gt;    .add(FooMock::foo)
&lt;&#x2F;span&gt;&lt;span&gt;    .inputs(matching!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;    .returns(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    .next()
&lt;&#x2F;span&gt;&lt;span&gt;    .add(..)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;    .build()
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This API is not that nice because there is no grouped indentation for one &amp;quot;unit of mock&amp;quot;.
It&#x27;s also too verbose for my taste, needing method calls like &lt;code&gt;.add&lt;&#x2F;code&gt; and &lt;code&gt;.inputs&lt;&#x2F;code&gt; which don&#x27;t add information.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s look at defining an API for a &amp;quot;unit of mock&amp;quot; first.
Remember the &lt;code&gt;struct foo&lt;&#x2F;code&gt; inside &lt;code&gt;mod FooMock&lt;&#x2F;code&gt;, the one that implements &lt;code&gt;MockFn&lt;&#x2F;code&gt;.
Let&#x27;s try to put a helper method in &lt;code&gt;MockFn&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;MockFn &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;mock&lt;&#x2F;span&gt;&lt;span&gt;() -&amp;gt; MockFnBuilder { .. }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;FooMock::foo::mock()
&lt;&#x2F;span&gt;&lt;span&gt;    .inputs(matching!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;    .returns(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Even better:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;MockFn &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;mock&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;matching&lt;&#x2F;span&gt;&lt;span&gt;: impl MatchingFn) -&amp;gt; MockFnBuilder&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; { .. }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;FooMock::foo::mock(matching!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;    .returns(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Even better (with the help of &lt;code&gt;rustfmt&lt;&#x2F;code&gt;):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;MockFn &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;mock&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;matching&lt;&#x2F;span&gt;&lt;span&gt;: impl MatchingFn) -&amp;gt; MockFnBuilder&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; { .. }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;FooMock::foo
&lt;&#x2F;span&gt;&lt;span&gt;    .mock(matching!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;    .returns(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Integrating this into the universal mocker builder:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;MockBuilder::new()
&lt;&#x2F;span&gt;&lt;span&gt;    .mock(FooMock::foo
&lt;&#x2F;span&gt;&lt;span&gt;        .mock(matching!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;        .returns(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    )
&lt;&#x2F;span&gt;&lt;span&gt;    .mock(..)
&lt;&#x2F;span&gt;&lt;span&gt;    .build()
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It&#x27;s a bit better than where we started, but not quite there.
I still don&#x27;t like the boilerplate-y &lt;code&gt;.mock&lt;&#x2F;code&gt; (or &lt;code&gt;.add&lt;&#x2F;code&gt;) call that&#x27;s required here.
Also there&#x27;s a &lt;code&gt;.build()&lt;&#x2F;code&gt; call that&#x27;s very Builder Pattern, and really doesn&#x27;t convey anything.&lt;&#x2F;p&gt;
&lt;p&gt;What I&#x27;d like is just &lt;em&gt;one function call&lt;&#x2F;em&gt; with one parameter that just returns the mocker.
This can be done using an array!&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Mocker &lt;&#x2F;span&gt;&lt;span&gt;{ .. }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Mocker &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;new&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;configs&lt;&#x2F;span&gt;&lt;span&gt;: impl IntoIterator&amp;lt;Item = MockFnBuilder&amp;lt;?&amp;gt;&amp;gt;) { .. }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Except that &lt;code&gt;MockFnBuilder&lt;&#x2F;code&gt; has to be a generic type because it needs to operate on the corresponding &lt;code&gt;MockFn&lt;&#x2F;code&gt;&#x27;s &lt;code&gt;Inputs&lt;&#x2F;code&gt; and &lt;code&gt;Response&lt;&#x2F;code&gt; types.&lt;&#x2F;p&gt;
&lt;p&gt;So if we can&#x27;t use that, maybe the &lt;code&gt;MockFnBuilder&amp;lt;F: MockFn&amp;gt;&lt;&#x2F;code&gt; can be converted to a &lt;code&gt;DynMockFnBuilder&lt;&#x2F;code&gt; before being passed to the array?
That would still require one extra line per mock config:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;Mocker::new([
&lt;&#x2F;span&gt;&lt;span&gt;    FooMock::foo
&lt;&#x2F;span&gt;&lt;span&gt;        .mock(matching!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;        .returns(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;        .into_dyn() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; &amp;lt;-- :(
&lt;&#x2F;span&gt;&lt;span&gt;])
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Sometimes I wish that Rust could do implicit type conversion..&lt;&#x2F;p&gt;
&lt;p&gt;But not today.
What&#x27;s nice about the array approach is that the genericity of each &lt;code&gt;MockFnBuilder&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; ends with each &lt;code&gt;.into_dyn()&lt;&#x2F;code&gt;, and the compiler has an easier job because each array item has the same type (it has to!).
The obvious &amp;quot;solution&amp;quot; to missing implicit type conversion is.. &lt;em&gt;tuples&lt;&#x2F;em&gt;.
With tuples we&#x27;ll end up with a big unique type for every unique mock configuration, the compiler will have a harder time, but this is Ergonomic (and elegant) API design!&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;Mocker::new((
&lt;&#x2F;span&gt;&lt;span&gt;    MockFoo::foo
&lt;&#x2F;span&gt;&lt;span&gt;        .mock(matching!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;        .returns(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;    MockBar::bar
&lt;&#x2F;span&gt;&lt;span&gt;        .mock(matching!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;        .returns(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I&#x27;m starting to like this!&lt;&#x2F;p&gt;
&lt;p&gt;Now the problem is the corny grammars: &amp;quot;Mock matching 1 returns 2&amp;quot;.
I think there&#x27;s too much use of the word &amp;quot;mock&amp;quot; everywhere.&lt;&#x2F;p&gt;
&lt;p&gt;To get a hint of what the helper function is going to be called, we can analyze the type-state in the mock builder:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;MockFoo::foo&lt;&#x2F;code&gt; a trait method&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;.mock(matching!(something))&lt;&#x2F;code&gt; describe the function call&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;.returns(something)&lt;&#x2F;code&gt; describe the response&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;After step 2 we have described a function call, so the &amp;quot;keyword&amp;quot; could include the word &amp;quot;call&amp;quot;.
In addition, it would be nice if it sounded as a general rule.
&amp;quot;Each time this function is called with these parameters, it should return this&amp;quot;.
&lt;code&gt;each_call&lt;&#x2F;code&gt; is nice.
We&#x27;ll also support &lt;code&gt;next_call&lt;&#x2F;code&gt; and &lt;code&gt;some_call&lt;&#x2F;code&gt; (the Unimock documentation explains the difference).&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;Mocker::new((
&lt;&#x2F;span&gt;&lt;span&gt;    MockFoo::foo
&lt;&#x2F;span&gt;&lt;span&gt;        .each_call(matching!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;        .returns(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;    MockBar::bar
&lt;&#x2F;span&gt;&lt;span&gt;        .next_call(matching!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;        .returns(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And what about &lt;code&gt;Mocker::new&lt;&#x2F;code&gt;?
It needs to accept a generic with a trait bound as its only parameter.
That trait will be called &lt;code&gt;Clause&lt;&#x2F;code&gt;, and must of course be implemented for tuples of up to N elements.
Using a trait like this makes it easy to factor out common clauses to helper functions.
As long is the trait is implemented for both tuples and the elements inside the tuples, it&#x27;s possible to build arbitrarily deep clause trees.&lt;&#x2F;p&gt;
&lt;p&gt;I think we have a good enough configuration API now, although all the details are not described here.
These are (very roughly) the steps that were taken before the Unimock API ended up the way it looks now.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;mock-the-ecosystem&quot;&gt;Mock the ecosystem!&lt;&#x2F;h2&gt;
&lt;p&gt;Unimock before 0.5 was intended to be used in application development for locally defined traits.
I only recently came to think of rust traits as living inside a big interconnected graph.&lt;&#x2F;p&gt;
&lt;p&gt;So unimock 0.5 introduces mocking of upstream crates from &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;core&#x2F;index.html&quot;&gt;core&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;&quot;&gt;std&lt;&#x2F;a&gt;.
The most notable ones are &lt;code&gt;Display&lt;&#x2F;code&gt;, &lt;code&gt;Debug&lt;&#x2F;code&gt;, &lt;code&gt;Read&lt;&#x2F;code&gt;, &lt;code&gt;Write&lt;&#x2F;code&gt; and &lt;code&gt;Seek&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;I&#x27;m not sure where to to take unimock next.
Should unimock depend on all kinds of third party crates or should it be the other way around?
It&#x27;s not yet clear to me what&#x27;s the ideal solution.&lt;&#x2F;p&gt;
&lt;p&gt;I&#x27;ll close off this post by posting a new fun test case from the repo, demonstrating how &lt;code&gt;Display&lt;&#x2F;code&gt; and &lt;code&gt;Write&lt;&#x2F;code&gt; works:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;use unimock::mock::core::fmt::DisplayMock;
&lt;&#x2F;span&gt;&lt;span&gt;use unimock::mock::std::io::WriteMock;
&lt;&#x2F;span&gt;&lt;span&gt;use unimock::*;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;test&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;test&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; All the clauses here use `next_call`
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; and therefore MUST happen in the specified order:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; mocker = Unimock::new((
&lt;&#x2F;span&gt;&lt;span&gt;        DisplayMock::fmt
&lt;&#x2F;span&gt;&lt;span&gt;            .next_call(matching!())
&lt;&#x2F;span&gt;&lt;span&gt;            .mutates(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;, _| write!(f, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;hello &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;unimock&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)),
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; NOTE: `write!` calls `write_all` which
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; is a default method that implicitly
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; gets re-routed into `write`:
&lt;&#x2F;span&gt;&lt;span&gt;        WriteMock::write
&lt;&#x2F;span&gt;&lt;span&gt;            .next_call(matching!(eq!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;hello &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)))
&lt;&#x2F;span&gt;&lt;span&gt;            .returns(Ok(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;6&lt;&#x2F;span&gt;&lt;span&gt;)),
&lt;&#x2F;span&gt;&lt;span&gt;        WriteMock::write
&lt;&#x2F;span&gt;&lt;span&gt;            .next_call(matching!(eq!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;unimock&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)))
&lt;&#x2F;span&gt;&lt;span&gt;            .returns(Ok(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;uni&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.len())),
&lt;&#x2F;span&gt;&lt;span&gt;        WriteMock::write
&lt;&#x2F;span&gt;&lt;span&gt;            .next_call(matching!(eq!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;mock&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)))
&lt;&#x2F;span&gt;&lt;span&gt;            .returns(Ok(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;mock&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.len())),
&lt;&#x2F;span&gt;&lt;span&gt;    ));
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    write!(&amp;amp;mut mocker.clone(), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;{mocker}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;).unwrap();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Unimock 0.4</title>
        <published>2022-11-27T00:00:00+00:00</published>
        <updated>2022-11-27T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://audunhalland.github.io/blog/unimock-0-4/" type="text/html"/>
        <id>https://audunhalland.github.io/blog/unimock-0-4/</id>
        
        <content type="html">&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;audunhalland&#x2F;unimock&quot;&gt;Unimock&lt;&#x2F;a&gt; (&lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;unimock&#x2F;latest&#x2F;unimock&#x2F;&quot;&gt;docs&lt;&#x2F;a&gt;) is a trait mocking library.
Its defining feature is that all generated mock implementations are implemented for the same type (&lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;unimock&#x2F;latest&#x2F;unimock&#x2F;struct.Unimock.html&quot;&gt;&lt;code&gt;Unimock&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;).
This design allows using a mock object where the type of the generic value is constrained by several trait bounds at the same time (e.g. &lt;code&gt;T: Foo + Bar&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;Other features:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Declarative verification of calls up front (executed at &lt;code&gt;drop&lt;&#x2F;code&gt;-time)&lt;&#x2F;li&gt;
&lt;li&gt;Argument matching through pattern matching or &lt;code&gt;Eq&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Partial mocking (though this needs to be manually integrated with some &amp;quot;canonical implementation&amp;quot;)&lt;&#x2F;li&gt;
&lt;li&gt;Versatile support for different types of return values, including borrowed values&lt;&#x2F;li&gt;
&lt;li&gt;Largely implemented via generics, the macro expansions keep the size of generated code to an absolute minimum&lt;&#x2F;li&gt;
&lt;li&gt;Safe Rust™&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;version-0-4&quot;&gt;Version 0.4&lt;&#x2F;h2&gt;
&lt;p&gt;Version 0.4 contains many improvements.
First and foremost, it introduces more internal traits in order to expose a simpler yet more powerful API to end users.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;mock-construction&quot;&gt;Mock construction&lt;&#x2F;h3&gt;
&lt;p&gt;There is now less boilerplate involved when instantiating a new mock object:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; unimock = Unimock::new((
&lt;&#x2F;span&gt;&lt;span&gt;    FooMock::foo
&lt;&#x2F;span&gt;&lt;span&gt;        .next_call(matching!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;        .returns(Some(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)),
&lt;&#x2F;span&gt;&lt;span&gt;    BarMock::bar
&lt;&#x2F;span&gt;&lt;span&gt;        .next_call(matching!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;        .returns(Ok(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;42&lt;&#x2F;span&gt;&lt;span&gt;)),
&lt;&#x2F;span&gt;&lt;span&gt;));
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;Unimock::new&lt;&#x2F;code&gt; accepts anything that implements &lt;code&gt;Clause&lt;&#x2F;code&gt;, which includes tuples up to 16 elements.
This eliminates the manual type-erasure step needed in version 0.3 (having to call &lt;code&gt;.in_order()&lt;&#x2F;code&gt; on each terminal clause).
There is a tradeoff though: Since the tuple elements all have different types, the compiler has to do more work.
In this case I do think that improved ergonomics are worth it.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;more-versatile-return-types&quot;&gt;More versatile return types&lt;&#x2F;h3&gt;
&lt;p&gt;In version 0.3, it wasn&#x27;t possible to specify an output value for a function returning &lt;code&gt;-&amp;gt; Option&amp;lt;&amp;amp;T&amp;gt;&lt;&#x2F;code&gt;.
This type is really a mix between an outer owned value and an inner borrowed value.&lt;&#x2F;p&gt;
&lt;p&gt;Version 0.4 introduces new abstractions to be able to represent this.
It includes specific support for &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;&#x2F;code&gt; and &lt;code&gt;Result&amp;lt;&amp;amp;T, E&amp;gt;&lt;&#x2F;code&gt;.
The longer term plan is to be able to &lt;code&gt;#[derive]&lt;&#x2F;code&gt; these capabilities for custom user-defined types.&lt;&#x2F;p&gt;
&lt;p&gt;Example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;unimock&lt;&#x2F;span&gt;&lt;span&gt;(api = FooMock)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Foo &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;arg&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;str&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Option&amp;lt;&amp;amp;String&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; u = Unimock::new(
&lt;&#x2F;span&gt;&lt;span&gt;    FooMock::foo
&lt;&#x2F;span&gt;&lt;span&gt;        .next_call(matching!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;        .returns(Some(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_string()))
&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;here, unimock automatically converts the &lt;code&gt;Option&amp;lt;String&amp;gt;&lt;&#x2F;code&gt; into an &lt;code&gt;Option&amp;lt;&amp;amp;String&amp;gt;&lt;&#x2F;code&gt; internally.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;improved-diagnostics-on-matching-failures&quot;&gt;Improved diagnostics on matching! failures&lt;&#x2F;h3&gt;
&lt;p&gt;Unimock will now try to diagnose what exactly went wrong when a mismatch happens.&lt;&#x2F;p&gt;
&lt;p&gt;Example&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;unimock&lt;&#x2F;span&gt;&lt;span&gt;(api = FooMock)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Foo &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;arg&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;str&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; u = Unimock::new(FooMock::foo.next_call(matching!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)).returns(()));
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Unimock as Foo&amp;gt;::foo(&amp;amp;u, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Running this code will produce the following terminal ouput:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;thread &amp;#39;foo::mismatch&amp;#39; panicked at &amp;#39;Foo::foo(&amp;quot;b&amp;quot;): Method invoked in the correct order (1), but inputs didn&amp;#39;t match Foo::foo(&amp;quot;a&amp;quot;) at tests&#x2F;foo.rs:42. 
&lt;&#x2F;span&gt;&lt;span&gt;Pattern mismatch for input #0 (actual &#x2F; expected):
&lt;&#x2F;span&gt;&lt;span&gt;Diff &amp;lt; left &#x2F; right &amp;gt; :
&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&amp;quot;b&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;quot;a&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Except only better:
Unimock uses &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;pretty_assertions&#x2F;latest&#x2F;pretty_assertions&#x2F;&quot;&gt;pretty_assertions&lt;&#x2F;a&gt; to write this diff to the terminal, so diffs are are actually printed with colored output.&lt;&#x2F;p&gt;
&lt;p&gt;Note that the &lt;code&gt;matching!()&lt;&#x2F;code&gt; macro uses pattern matching by default.
Printing a &lt;code&gt;Debug&lt;&#x2F;code&gt;-based diff on a pattern mismatch might not produce a good diff output, since patterns could be much smaller than the actuall value due to spreads or other variations in syntax.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;matching!()&lt;&#x2F;code&gt; now also supports matching using &lt;code&gt;Eq&lt;&#x2F;code&gt;!
Just write &lt;code&gt;matching!(eq!(arg0), eq!(arg1))&lt;&#x2F;code&gt; to match against full values instead of patterns.
If the values implement &lt;code&gt;Debug&lt;&#x2F;code&gt;, you will likely get a high quality diff.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;gats-to-reduce-the-amount-of-generated-code&quot;&gt;GATs to reduce the amount of generated code&lt;&#x2F;h3&gt;
&lt;p&gt;Unimock uses a lot lifetime-generic data type abstractions.
Although these constructs could be expressed in older versions of Rust,
Generic Associated Types allow unimock to be much more compact,
greatly reducing the amount of generated code.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;other-changes&quot;&gt;Other changes&lt;&#x2F;h3&gt;
&lt;p&gt;See the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;audunhalland&#x2F;unimock&#x2F;blob&#x2F;main&#x2F;CHANGELOG.md#040---2022-11-20&quot;&gt;unimock changelog&lt;&#x2F;a&gt; for other changes in 0.4.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-future-of-unimock&quot;&gt;The future of unimock&lt;&#x2F;h2&gt;
&lt;p&gt;I intend to continue to support unimock, and attempt to actively dogfood it for internal projects at work as much as possible.&lt;&#x2F;p&gt;
&lt;p&gt;Unimock is still a project in early development, and I continue to try and find use cases that demonstrate its potential shortcomings.&lt;&#x2F;p&gt;
&lt;p&gt;A very recent experiment I did was to try and generate a mock implementation for &lt;code&gt;std::io::Read&lt;&#x2F;code&gt; (and &lt;code&gt;Write&lt;&#x2F;code&gt;).
There I hit a new roadblock, because of the signature of &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;io&#x2F;trait.Read.html#method.read_vectored&quot;&gt;&lt;code&gt;Read::read_vectored&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;.
In this signature, the object receives&#x2F;borrows a parameter with an internal lifetime bound to &lt;code&gt;&#x27;self&lt;&#x2F;code&gt;.
Unimock&#x27;s traits aren&#x27;t yet able to express this.&lt;&#x2F;p&gt;
&lt;p&gt;Some more upcoming changes to core traits are to be expected, for unimock to be able to work with more interesting function signatures.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>An inquiry into code and language quality</title>
        <published>2022-06-25T00:00:00+00:00</published>
        <updated>2022-06-25T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://audunhalland.github.io/blog/inquiry-into-code-and-language-quality/" type="text/html"/>
        <id>https://audunhalland.github.io/blog/inquiry-into-code-and-language-quality/</id>
        
        <content type="html">&lt;p&gt;I recently had a very small dispute with someone about &lt;em&gt;code quality&lt;&#x2F;em&gt;.
Afterwards, I wasn&#x27;t sure if I fully understood the concept, so I wanted to write something down to organize my thoughts around this topic.&lt;&#x2F;p&gt;
&lt;p&gt;In my experience, people, including myself, will name this code or that code as &lt;em&gt;bad&lt;&#x2F;em&gt; or &lt;em&gt;good&lt;&#x2F;em&gt; quality, often without much thought behind it.
This could be because &lt;em&gt;quality&lt;&#x2F;em&gt; could be a measure of whether we subjectively like what we see, or not.
But I suspect that it may be possible to speak about &lt;em&gt;objective quality&lt;&#x2F;em&gt; in the context of computer code.&lt;&#x2F;p&gt;
&lt;p&gt;I also find it amusing to argue with people on what are good and bad programming languages. More on that towards the end.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;objective-quality&quot;&gt;Objective quality&lt;&#x2F;h2&gt;
&lt;p&gt;I&#x27;ll try to define some terminology.
A &lt;em&gt;computer program&lt;&#x2F;em&gt; is made from a &lt;em&gt;code base&lt;&#x2F;em&gt;.
A code base produces different computer programs at different points in time, because the code base is being changed by humans over time.
A code base at a point in time is usually referred to as just &lt;em&gt;(the) code&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Code and code bases is by and for humans, programs are for computers.
Code bases may be very large or very small.
Compilers and interpreters are programs that implement a programming language, whose job is to turn code into computer programs.&lt;&#x2F;p&gt;
&lt;p&gt;Based on this, we can suggest the most important &lt;em&gt;code quality&lt;&#x2F;em&gt;:&lt;&#x2F;p&gt;
&lt;h4 id=&quot;1-the-code-can-be-turned-into-a-valid-computer-program&quot;&gt;1. The code can be turned into a valid computer program.&lt;&#x2F;h4&gt;
&lt;p&gt;This can be done using a compiler or an interpreter. Failing to execute a single program
instruction from the resulting program will mean that this quality is not present.&lt;&#x2F;p&gt;
&lt;p&gt;Code having this quality is simply &lt;em&gt;better&lt;&#x2F;em&gt; than code lacking this quality.&lt;&#x2F;p&gt;
&lt;p&gt;Moving on..&lt;&#x2F;p&gt;
&lt;h4 id=&quot;2-executing-the-program-produced-from-the-code-does-what-the-programmer-intended&quot;&gt;2. Executing the program produced from the code does what the programmer intended.&lt;&#x2F;h4&gt;
&lt;p&gt;This quality is related to the absence of bugs in the program.
If the code looks like it might do one thing, but then the program does a different thing, it will lead to a decrease in general quality, because of a decrease in this &lt;em&gt;specifc&lt;&#x2F;em&gt; quality.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;3-it-is-possible-to-find-the-source-of-a-bug-by-just-reading-the-code&quot;&gt;3. It is possible to find the source of a bug by just reading the code.&lt;&#x2F;h4&gt;
&lt;p&gt;This quality assumes some human skill, but that&#x27;s necessary for writing code that verify as valid computer programs in the first place.&lt;&#x2F;p&gt;
&lt;p&gt;If this quality is present in code, it is possible to read through the code lines and find problems without using other tools like debuggers.
It is related to &lt;em&gt;code readablility&lt;&#x2F;em&gt;, but that&#x27;s more subjective and not the same thing.&lt;&#x2F;p&gt;
&lt;p&gt;This quality is about completeness, and code being more excplicit than implicit.
The code should do what it looks like it does, not more, and not less.
It shouldn&#x27;t try to hide any details.
It seems somewhat related to the previous quality:
Code that has a fewer number of bugs, tends to be more explicit than code that contains more bugs.
There could be several reasons for that, but I can think of two, both of which relate to the previously mentioned qualities:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The code base has accumulated bugfixes over time, because bugs have been found and the code base has since been corrected over and over again.
Code is usually less explicit before a bug fix than after: Most bugfixes involve &lt;em&gt;adding some more code&lt;&#x2F;em&gt; (though this is not always true).&lt;&#x2F;li&gt;
&lt;li&gt;The code needs to be valid computer program in order to be useful at all, and the compiler&#x2F;interpreter &lt;em&gt;required&lt;&#x2F;em&gt; the programmer to be explicit.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;em&gt;Explicit&lt;&#x2F;em&gt; programs that are valid are better then &lt;em&gt;implicit&lt;&#x2F;em&gt; programs that are valid.&lt;&#x2F;p&gt;
&lt;p&gt;But there is nothing about &lt;em&gt;code quality&lt;&#x2F;em&gt; in itself that make any of these mentioned qualities related to each other.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;programming-language-quality&quot;&gt;Programming language quality&lt;&#x2F;h2&gt;
&lt;p&gt;A programming language is required for turning code into a computer program. The programming language either accepts or rejects code validity.&lt;&#x2F;p&gt;
&lt;p&gt;Are we allowed to say that some programming languages have better quality than others?&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s try.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;1-a-programming-language-that-rejects-more-programs-has-better-quality-than-one-that-rejects-less&quot;&gt;1. A programming language that rejects more programs has better quality than one that rejects less&lt;&#x2F;h4&gt;
&lt;p&gt;This is trivially false, because a language that accepts no programs is not a good quality programming language.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;2-a-programming-language-has-good-quality-if-it-objectively-rejects-low-quality-code&quot;&gt;2. A programming language has good quality if it objectively rejects low quality code&lt;&#x2F;h4&gt;
&lt;p&gt;I think we can say that a programming language that rejects more buggy programs than another one is a better programming language (if
all other things are equal).&lt;&#x2F;p&gt;
&lt;p&gt;If this is true, using a higher quality programming language will lead to higher quality code.&lt;&#x2F;p&gt;
&lt;p&gt;To illustrate: I believe that many developers like to use linters that are able detect common mistakes.
So let&#x27;s compare a permissive language with and without a linter.
With the linter turned on, the developer would likely write fewer bugs to begin with, i.e. higher quality code.
Therefore, if we pretend that the language + linter were combined together to form a new language, that language would have higher quality than the original permissive language isolated.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion-for-now&quot;&gt;Conclusion for now&lt;&#x2F;h2&gt;
&lt;p&gt;Yes, I do think we can speak of both objective quality in code, and objective quality of languages.
Of course, I didn&#x27;t cover every possible aspect of code and language here, I was just trying to find some examples from which
we can state something objective.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>The entrait pattern</title>
        <published>2022-06-03T00:00:00+00:00</published>
        <updated>2022-06-03T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://audunhalland.github.io/blog/entrait-pattern/" type="text/html"/>
        <id>https://audunhalland.github.io/blog/entrait-pattern/</id>
        
        <content type="html">&lt;p&gt;&lt;a href=&quot;&#x2F;blog&#x2F;testability-reimagining-oop-design-patterns-in-rust&#x2F;&quot;&gt;Last time&lt;&#x2F;a&gt; I presented an idea for a design
pattern for Rust applications, that can help with testing of business logic. In short, we need a way to
turn dependencies into &lt;em&gt;inputs&lt;&#x2F;em&gt; when we run tests, so that we can test function bodies as units.&lt;&#x2F;p&gt;
&lt;p&gt;The last blog post presented some workable ideas, which suffered a bit from being too verbose to write by hand. This time
I will write about a macro that I named
&lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;entrait&#x2F;0.3.0&#x2F;entrait&#x2F;index.html&quot;&gt;&lt;code&gt;entrait&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;,
which removes this boilerplate. The &lt;em&gt;entrait pattern&lt;&#x2F;em&gt; is a certain code style and design technique
that is used together with the macro.&lt;&#x2F;p&gt;
&lt;p&gt;To start from the beginning: The main problem we would like to tackle is &lt;em&gt;unit testing&lt;&#x2F;em&gt; of business logic:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;my_function&lt;&#x2F;span&gt;&lt;span&gt;() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    your_function() + some_other_function()
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We would like to be able to write a test for &lt;code&gt;my_function&lt;&#x2F;code&gt; that does not depend on any
implementation details from &lt;code&gt;your_function&lt;&#x2F;code&gt; or &lt;code&gt;some_other_function&lt;&#x2F;code&gt;. Instead we&#x27;d like to
treat these functions differently only when we&#x27;re testing: We want to explicitly specify
what these functions are &lt;em&gt;returning&lt;&#x2F;em&gt;, as another kind of input to the function we are &lt;em&gt;testing&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;entrait&quot;&gt;Entrait&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;em&gt;Entrait&lt;&#x2F;em&gt; is just a word that I might have invented (not sure!).
It means to &lt;em&gt;put&#x2F;enclose something in a trait&lt;&#x2F;em&gt;, and this is just what the macro does.
When you have written a regular
function, you can annotate it with &lt;code&gt;entrait&lt;&#x2F;code&gt; to automatically generate a &lt;em&gt;single-method trait&lt;&#x2F;em&gt; based on its signature:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;entrait&lt;&#x2F;span&gt;&lt;span&gt;(pub MyFunction)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;my_function&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The arguments to entrait is an optional visibility specifier, then the name of the trait to generate.&lt;&#x2F;p&gt;
&lt;p&gt;The entrait macro operates in &lt;em&gt;append only&lt;&#x2F;em&gt; mode, so the original function is not changed in any way and is outputted verbatim.
The generated code that gets appended, includes the trait definition:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;MyFunction &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;my_function&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;along with a generic implementation for &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;implementation&#x2F;latest&#x2F;implementation&#x2F;struct.Impl.html&quot;&gt;&lt;code&gt;implementation::Impl&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;
with a &lt;code&gt;Sync&lt;&#x2F;code&gt;&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; bound for &lt;code&gt;T&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt; MyFunction for ::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;implementation&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    where T: Sync
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;my_function&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        my_function() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; invoking our original function
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is the very basics of entrait.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;specifying-dependencies&quot;&gt;Specifying dependencies&lt;&#x2F;h2&gt;
&lt;p&gt;The basic entrait usage is not that interesting in itself. The pattern becomes more interesting when we
hook up different traits, and make one function depend on another set of functions.&lt;&#x2F;p&gt;
&lt;p&gt;Consider a Rust &lt;em&gt;method&lt;&#x2F;em&gt;, which has a special &lt;code&gt;self&lt;&#x2F;code&gt;-receiver as its first argument. Entraited functions
work in a similar way, but instead of the first parameter being a self-receiver, it specifies &lt;em&gt;dependencies&lt;&#x2F;em&gt;.
The dependencies of an entraited function is a set of traits. We can specify them in the following way:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;entrait&lt;&#x2F;span&gt;&lt;span&gt;(MyFunction)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;my_function&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;deps&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;impl YourFunction&lt;&#x2F;span&gt;&lt;span&gt; + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;SomeOtherFunction&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;some_arg&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32
&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    deps.your_function(some_arg);
&lt;&#x2F;span&gt;&lt;span&gt;    deps.some_other_function();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The macro understands the type syntax of the first parameter, and will adjust its default
implementation bounds (for &lt;code&gt;Impl&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;) accordingly. The only thing we need to know for now, is that &lt;code&gt;deps&lt;&#x2F;code&gt; will be
a reference to some type on which we can call the methods &lt;code&gt;your_function&lt;&#x2F;code&gt; and &lt;code&gt;some_other_function&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Using the dependency notation, we can easily build up complex directed dependency graphs with very little code:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;entrait&lt;&#x2F;span&gt;&lt;span&gt;(Foo)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;deps&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;impl Bar, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;arg&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    deps.bar()
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;entrait&lt;&#x2F;span&gt;&lt;span&gt;(Bar)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;bar&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;deps&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;impl Baz&lt;&#x2F;span&gt;&lt;span&gt; + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Qux&lt;&#x2F;span&gt;&lt;span&gt;), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;arg&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    deps.baz(arg) + deps.qux(arg)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;entrait&lt;&#x2F;span&gt;&lt;span&gt;(Baz)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;baz&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;deps&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;impl Qux, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;arg&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    deps.qux(arg) * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;2
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;entrait&lt;&#x2F;span&gt;&lt;span&gt;(Qux)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; this function has no dependency bounds:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;qux&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt;(_: &amp;amp;T, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;arg&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    arg * arg
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;generics-and-application-state&quot;&gt;Generics and application state&lt;&#x2F;h2&gt;
&lt;p&gt;What we have created so far, is generic on two different levels. First of all,
the function&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;entrait&lt;&#x2F;span&gt;&lt;span&gt;(MyFunction)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;my_function&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;deps&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;impl YourFunction) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;is generic:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Because the &lt;code&gt;deps&lt;&#x2F;code&gt; parameter can be &lt;em&gt;any type&lt;&#x2F;em&gt; that implements &lt;code&gt;YourFunction&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Beacuse the trait implementation provided out of the box, &lt;code&gt;impl&amp;lt;T&amp;gt; MyFunction for implementation::Impl&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;,
is defined for &lt;em&gt;any&lt;&#x2F;em&gt; &lt;code&gt;T&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;The first kind of genericness is covered in the next section, and is related to real vs. fake
implementations and &lt;em&gt;mocking&lt;&#x2F;em&gt;.
The second kind of generic parameter, the &lt;code&gt;T&lt;&#x2F;code&gt; in &lt;code&gt;Impl&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;, is intended to be a &lt;em&gt;placeholder&lt;&#x2F;em&gt; for
the type that we will choose to represent the &lt;em&gt;state&lt;&#x2F;em&gt; of our concrete application.&lt;&#x2F;p&gt;
&lt;p&gt;An application often needs e.g. configuration parameters, connection pools, caches, various data it needs
to operate correctly. An entraited function with generic dependencies can receive any &lt;code&gt;T&lt;&#x2F;code&gt; as application state:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; application: Impl&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; = Impl::new(true);
&lt;&#x2F;span&gt;&lt;span&gt;application.my_function();
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Somewhere, usually deep down in our dependency graph, we would like to perform concrete operations on our
chosen application state, for example &lt;em&gt;borrowing data&lt;&#x2F;em&gt; from it. Entrait lets you do that very easily, and
the trick is just to make &lt;code&gt;deps&lt;&#x2F;code&gt; be a reference to that concrete type:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;entrait&lt;&#x2F;span&gt;&lt;span&gt;(FetchStuffFromApi)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; still generic:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;fetch_stuff_from_api&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;deps&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;impl GetApiUrl) -&amp;gt; Stuff {
&lt;&#x2F;span&gt;&lt;span&gt;    some_http_lib::get(deps.get_api_url())
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;AppConfig &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;api_url&lt;&#x2F;span&gt;&lt;span&gt;: String,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;entrait&lt;&#x2F;span&gt;&lt;span&gt;(GetApiUrl)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; concrete:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;get_api_url&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;config&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;AppConfig) -&amp;gt; &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;str &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;amp;config.api_url
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;What will happen now, is that the trait &lt;code&gt;GetApiUrl&lt;&#x2F;code&gt; will only be implemented for &lt;code&gt;Impl&amp;lt;AppConfig&amp;gt;&lt;&#x2F;code&gt;.
This means that &lt;code&gt;fetch_stuff_from_api&lt;&#x2F;code&gt;, which depends on a type that implements &lt;code&gt;GetApiUrl&lt;&#x2F;code&gt;, in practice
will inherit that same bound. As soon as we introduced a concrete leaf, our whole application became concretized!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;testing-and-mocking&quot;&gt;Testing and mocking&lt;&#x2F;h2&gt;
&lt;p&gt;So far, we have seen some constructs that enable some degree of abstraction when designing applications.
The way the &lt;code&gt;deps&lt;&#x2F;code&gt; parameter specifies bounds as a set of traits is a manifestation of the
&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dependency_inversion_principle&quot;&gt;dependency inversion principle&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The whole point of this in the first place, was to be able to write a unit test for a function.
The function we started with was a &lt;code&gt;my_function(..) -&amp;gt; i32&lt;&#x2F;code&gt;
which sums toghether the outputs of &lt;code&gt;your_function&lt;&#x2F;code&gt; and &lt;code&gt;some_other_function&lt;&#x2F;code&gt;.
Let&#x27;s write this using entrait:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;entrait&lt;&#x2F;span&gt;&lt;span&gt;(MyFunction)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;my_function&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;deps&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;impl YourFunction&lt;&#x2F;span&gt;&lt;span&gt; + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;SomeOtherFunction&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    deps.your_function() + deps.some_other_function()
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To test that this function works, we should be able to give it two numbers, e.g. &lt;code&gt;1&lt;&#x2F;code&gt; and &lt;code&gt;2&lt;&#x2F;code&gt;, and check
that it in fact produces the number &lt;code&gt;3&lt;&#x2F;code&gt;. If it did that, we can assume that it performed addition correctly.
We need a way to say that in the test, &lt;code&gt;your_function&lt;&#x2F;code&gt; should have the output value of &lt;code&gt;1&lt;&#x2F;code&gt;, and &lt;code&gt;some_other_function&lt;&#x2F;code&gt;
should have the output value of &lt;code&gt;2&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;This is where mocking enters the picture. We need &lt;em&gt;mock implementations&lt;&#x2F;em&gt; of the traits &lt;code&gt;YourFunction&lt;&#x2F;code&gt; and &lt;code&gt;SomeOtherFunction&lt;&#x2F;code&gt;,
and crucially, it must be &lt;em&gt;one type&lt;&#x2F;em&gt; that implements both.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;unimock&quot;&gt;Unimock&lt;&#x2F;h2&gt;
&lt;p&gt;Enter &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;unimock&quot;&gt;unimock&lt;&#x2F;a&gt;, a new mock crate that is designed to be the testing companion to &lt;code&gt;entrait&lt;&#x2F;code&gt;. &lt;em&gt;Uni&lt;&#x2F;em&gt; means &lt;em&gt;one&lt;&#x2F;em&gt;,
and the core idea is that unimock exports one struct, &lt;code&gt;Unimock&lt;&#x2F;code&gt;, which acts as an additional implementation target for
your traits.&lt;&#x2F;p&gt;
&lt;p&gt;In entrait, unimock support is opt-in. The basic entrait usage does &lt;em&gt;not&lt;&#x2F;em&gt; generate a mock implementation:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;use entrait::*;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;entrait&lt;&#x2F;span&gt;&lt;span&gt;(YourFunction)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;your_function&lt;&#x2F;span&gt;&lt;span&gt;() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32 &lt;&#x2F;span&gt;&lt;span&gt;{ todo!() }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The mock implementation is added when entrait is imported from an alternative path:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;use entrait::unimock::*;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;entrait&lt;&#x2F;span&gt;&lt;span&gt;(YourFunction)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;your_function&lt;&#x2F;span&gt;&lt;span&gt;() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32 &lt;&#x2F;span&gt;&lt;span&gt;{ todo!() }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we write it like that, entrait will generate &lt;em&gt;two&lt;&#x2F;em&gt; implementations of &lt;code&gt;YourFunction&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;for &lt;code&gt;implementation::Impl&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;for &lt;code&gt;unimock::Unimock&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;If we entrait &lt;code&gt;your_function&lt;&#x2F;code&gt; and &lt;code&gt;some_other_function&lt;&#x2F;code&gt; like this, with unimock implementations,
we can easily test &lt;code&gt;my_function&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;use unimock::*;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;test&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;my_function_should_add_two_numbers&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; deps = mock([
&lt;&#x2F;span&gt;&lt;span&gt;        your_function::Fn::each_call(matching!())
&lt;&#x2F;span&gt;&lt;span&gt;            .returns(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;            .in_any_order(),
&lt;&#x2F;span&gt;&lt;span&gt;        some_other_function::Fn::each_call(matching!())
&lt;&#x2F;span&gt;&lt;span&gt;            .returns(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;            .in_any_order(),
&lt;&#x2F;span&gt;&lt;span&gt;    ]);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    assert_eq!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;, my_function(&amp;amp;deps));
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;deeper-integration-tests-with-entrait-and-unimock&quot;&gt;Deeper integration tests with entrait and unimock&lt;&#x2F;h3&gt;
&lt;p&gt;A testing pattern seen in various OOP languages is mocking out business
logic at an &lt;em&gt;arbitrary distance&lt;&#x2F;em&gt; from the direct function being tested.
I think in some circles this might be referred to as &lt;em&gt;integration testing&lt;&#x2F;em&gt;.
Sometimes a deeper integration test is the best testing strategy for a particular problem.&lt;&#x2F;p&gt;
&lt;p&gt;The real advantage, the &lt;em&gt;crux&lt;&#x2F;em&gt; if you will, about the entrait pattern, is that
both unit and integration tests (of arbitrary depth!) become very much a reality.&lt;&#x2F;p&gt;
&lt;p&gt;Recall that our entraited functions are just ordinary, generic functions:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;my_function&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;deps&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;impl YourFunction&lt;&#x2F;span&gt;&lt;span&gt; + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;SomeOtherFunction&lt;&#x2F;span&gt;&lt;span&gt;)) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    deps.your_function() + deps.some_other_function()
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;deps&lt;&#x2F;code&gt; can be a reference to any type that implements the given traits.
&lt;code&gt;Unimock&lt;&#x2F;code&gt; matches that criteria, and we pass it into deps to unit test the function.&lt;&#x2F;p&gt;
&lt;p&gt;What happens when &lt;code&gt;Unimock::your_function()&lt;&#x2F;code&gt; is called? Unimock must be configured before it&#x27;s used.
For example, it can match input patterns in order to find some value to return.&lt;&#x2F;p&gt;
&lt;p&gt;But unimock has another mode, which is called &lt;em&gt;unmocking:&lt;&#x2F;em&gt; Instead of returning a pre-configured value,
it can be instructed to &lt;em&gt;not mock&lt;&#x2F;em&gt;, but &lt;em&gt;call some implementation&lt;&#x2F;em&gt; instead. Because we used the entrait
pattern, that implementation is right in our hands, it&#x27;s that original, handwritten generic function.&lt;&#x2F;p&gt;
&lt;p&gt;There are two main ways to configure a unimock instance:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;unimock::mock(clauses)&lt;&#x2F;code&gt; - Every interaction must be declared up front. If not, you&#x27;ll get a panic.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;unimock::spy(clauses)&lt;&#x2F;code&gt; - Every interaction is &lt;em&gt;unmocked&lt;&#x2F;em&gt; by default.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;A &lt;code&gt;Unimock&lt;&#x2F;code&gt; value created with &lt;code&gt;unimock::spy&lt;&#x2F;code&gt; is an alternative implementation of your entire&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; entraited application.
With that kind of setup, you can start at the other end, i.e. instead of specifying the value of each
dependency to your unit test, you can instead say which interfaces to &lt;em&gt;mock out&lt;&#x2F;em&gt;. Subtractive instead of additive mocking.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;testing-an-application-s-external-interface&quot;&gt;Testing an application&#x27;s external interface&lt;&#x2F;h2&gt;
&lt;p&gt;Consider a REST API where we would like to test the interface of the API without invoking the
application&#x27;s inner business logic. REST handlers in Rust are usually &lt;code&gt;async fn&lt;&#x2F;code&gt;s passed to some web framework.
I will present a simple example using &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;axum&quot;&gt;axum&lt;&#x2F;a&gt; here:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;my_handler&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;A&amp;gt;(
&lt;&#x2F;span&gt;&lt;span&gt;    Extension(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;app&lt;&#x2F;span&gt;&lt;span&gt;): Extension&amp;lt;A&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; ResponseType
&lt;&#x2F;span&gt;&lt;span&gt;    where A: SomeEntraitMethod + Sized + Clone + Send + Sync + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;static
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    app.some_entrait_method()
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can make a generic Axum &lt;code&gt;Router&lt;&#x2F;code&gt; using the same trait bounds, but duplicating these trait bounds
for a lot of different endpoints sounds a bit tedious. A solution to that could be to group related
handlers together in a generic struct, and have the handlers as static methods of that struct:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;MyApi&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;D&amp;gt;(std::marker::PhantomData&amp;lt;D&amp;gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;D&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;MyApi&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;D&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    D: SomeEntraitMethod + SomeOtherEntraitMethod + Sized + Clone + Send + Sync + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;static
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;router&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;        Router::new()
&lt;&#x2F;span&gt;&lt;span&gt;            .route(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;&#x2F;api&#x2F;foo&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, get(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;::foo))
&lt;&#x2F;span&gt;&lt;span&gt;            .route(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;&#x2F;api&#x2F;bar&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, get(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;::bar))
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;        Extension(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;deps&lt;&#x2F;span&gt;&lt;span&gt;): Extension&amp;lt;D&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; ResponseType {
&lt;&#x2F;span&gt;&lt;span&gt;        deps.some_entrait_method().await
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;bar&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;        Extension(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;deps&lt;&#x2F;span&gt;&lt;span&gt;): Extension&amp;lt;D&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; ResponseType {
&lt;&#x2F;span&gt;&lt;span&gt;        deps.some_other_entrait_method().await
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;entrait-and-async&quot;&gt;entrait and &lt;code&gt;async&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;The last example used &lt;code&gt;async fn&lt;&#x2F;code&gt;, but async functions in traits are not supported out of the box in current Rust.
The way around that for now is to use &lt;code&gt;#[async_trait]&lt;&#x2F;code&gt;. Entrait supports this by accepting a keyword argument list:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;entrait&lt;&#x2F;span&gt;&lt;span&gt;(Foo, async_trait=true)]
&lt;&#x2F;span&gt;&lt;span&gt;async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This has been designed in an opt-in manner to make it more visible that we are paying the cost of heap allocation
for every function invocation. When Rust one day supports &lt;code&gt;async fn&lt;&#x2F;code&gt; in traits natively, you should be able
to remove this opt-in feature and things should then work in the same manner as synchronous functions.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion-and-further-reading&quot;&gt;Conclusion and further reading&lt;&#x2F;h2&gt;
&lt;p&gt;The entrait pattern and related crates are in an experimental state.&lt;&#x2F;p&gt;
&lt;p&gt;What I&#x27;m hoping to achieve with this blog post is some feedback on the ideas and current implementation. I&#x27;m hoping
some people will find the time to try it out, and maybe find flaws in the design that could be improved.&lt;&#x2F;p&gt;
&lt;p&gt;This blog post does not go into great depth about &lt;code&gt;entrait&lt;&#x2F;code&gt; or &lt;code&gt;unimock&lt;&#x2F;code&gt;.
You will hopefully find much more useful information if you visit respective rustdoc pages for each crate:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;github&lt;&#x2F;th&gt;&lt;th&gt;crates.io&lt;&#x2F;th&gt;&lt;th&gt;docs.rs&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;audunhalland&#x2F;entrait&quot;&gt;entrait&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;entrait&#x2F;0.3.0&quot;&gt;0.3&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;entrait&#x2F;0.3.0&#x2F;entrait&#x2F;index.html&quot;&gt;docs&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;audunhalland&#x2F;unimock&quot;&gt;unimock&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;unimock&#x2F;0.2.0&quot;&gt;0.2&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;unimock&#x2F;0.2.0&#x2F;unimock&#x2F;index.html&quot;&gt;docs&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;audunhalland&#x2F;implementation&quot;&gt;implementation&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;implementation&quot;&gt;0.1&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;implementation&quot;&gt;docs&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;My next plan for entrait is to develop a full-fledged example application. I will likely put it in the &lt;code&gt;examples&#x2F;&lt;&#x2F;code&gt; directory in the entrait repository.
Meanwhile, you can take a look at the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;audunhalland&#x2F;entrait&#x2F;tree&#x2F;main&#x2F;tests&quot;&gt;tests&#x2F;&lt;&#x2F;a&gt; directory, which already contains a handful of
good examples.&lt;&#x2F;p&gt;
&lt;p&gt;At least I hope that you found some of this to be interesting to read. I surely had an interesting time developing it and writing about it!&lt;&#x2F;p&gt;
&lt;h5 id=&quot;footnotes&quot;&gt;Footnotes&lt;&#x2F;h5&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;&lt;em&gt;On &lt;code&gt;Sync&lt;&#x2F;code&gt; bound for &lt;code&gt;T&lt;&#x2F;code&gt;&lt;&#x2F;em&gt;: &lt;code&gt;T&lt;&#x2F;code&gt; should model an immutable application environment. Entrait is designed to work on multithreaded async executors,
hence the &lt;code&gt;Sync&lt;&#x2F;code&gt; bound. Mutable caches and similar should be modelled with interior mutability, e.g. &lt;code&gt;Mutex&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;There is one kind of function that cannot be automatically unmocked. It&#x27;s those functions that have non-generic
&lt;code&gt;deps&lt;&#x2F;code&gt; that should live at the leaf level of a dependency graph:&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;entrait&lt;&#x2F;span&gt;&lt;span&gt;(Foo)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;deps&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;SomeConcreteType) {}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If you create a default &lt;code&gt;unimock::spy&lt;&#x2F;code&gt;, a call to &lt;code&gt;Unimock::foo&lt;&#x2F;code&gt; will panic. But fortunately, &lt;code&gt;SomeConcreteType&lt;&#x2F;code&gt;
is not part of &lt;code&gt;Foo::foo&lt;&#x2F;code&gt;&#x27;s signature, so it can still be mocked normally.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Testability: Reimagining OOP design patterns in Rust</title>
        <published>2022-04-30T00:00:00+00:00</published>
        <updated>2022-04-30T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://audunhalland.github.io/blog/testability-reimagining-oop-design-patterns-in-rust/" type="text/html"/>
        <id>https://audunhalland.github.io/blog/testability-reimagining-oop-design-patterns-in-rust/</id>
        
        <content type="html">&lt;p&gt;I&#x27;m going to look at design patterns that enables easy code testability. Most of the code
I write at work is written in a traditional object-oriented language, and is almost
exclusively using the pattern known as &lt;strong&gt;Dependency Injection&lt;&#x2F;strong&gt; (DI).&lt;&#x2F;p&gt;
&lt;p&gt;Quick outline:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;A look into how DI is used in the field, in development environments considered more orthodox than Rust&lt;&#x2F;li&gt;
&lt;li&gt;A look at typical industry-standard Rust code with questions like &lt;em&gt;is it well tested?&lt;&#x2F;em&gt; If not, &lt;em&gt;Is it easy to change that&lt;&#x2F;em&gt;?&lt;&#x2F;li&gt;
&lt;li&gt;Look at how good patterns from other languages can be brought to Rust, &lt;em&gt;without also taking the idioms that are foreign to Rust&lt;&#x2F;em&gt;. Take &lt;strong&gt;only&lt;&#x2F;strong&gt; the things tht actually provide value.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;This is the first in a series of posts, with the end goal of presenting a full ergonomic design
pattern for Rust applications that enables easy testability everywhere.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;testing-terminology&quot;&gt;Testing terminology&lt;&#x2F;h3&gt;
&lt;p&gt;We have some &lt;em&gt;application&lt;&#x2F;em&gt; (a structured computer program) which is fairly modularized. The most interesting module of a modern program is the &lt;em&gt;function&lt;&#x2F;em&gt;.
We would like to verify that the functions do what they are supposed to do, so we write a &lt;em&gt;test program&lt;&#x2F;em&gt; - a meta program that links
to the original program. The test program calls the functions of the original program with some inputs, and execute some assertions on
the outputs.&lt;&#x2F;p&gt;
&lt;p&gt;If things only were that simple! We forgot that an &lt;em&gt;application&lt;&#x2F;em&gt; usually has very deep call graphs. If we test a very high level
function, it will usually call into layer upon layer of intermediate steps before returning an answer, and sometimes it will even perform I&#x2F;O.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;unit-tests&quot;&gt;Unit tests&lt;&#x2F;h4&gt;
&lt;p&gt;Functions are units that represents some computation. When we test a function, we&#x27;d like to test &lt;em&gt;only&lt;&#x2F;em&gt; that function,
&lt;em&gt;the code within that function body&lt;&#x2F;em&gt;. We don&#x27;t (necessarily) want to test everything else that the function directly or indirectly calls out to.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;business-logic-vs-utilities&quot;&gt;Business logic vs. utilities&lt;&#x2F;h4&gt;
&lt;p&gt;I like to group functions into these two categories. Business logic is deep, but utilities are shallow. An example of a utility
in the context of an application, could be e.g. &lt;code&gt;HashMap&lt;&#x2F;code&gt;. If the function we are testing uses a HashMap, we just let it do so, because it&#x27;s
not considered a Business Logic dependency, it&#x27;s just a utility.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;inversion-of-control&quot;&gt;Inversion of control&lt;&#x2F;h4&gt;
&lt;p&gt;Business logic will usually depend on &lt;em&gt;lower level&lt;&#x2F;em&gt; business logic. It is typically this kind of dependency we want to &amp;quot;cut off&amp;quot; when
executing a unit test. In the test, we want to treat the &lt;em&gt;output&lt;&#x2F;em&gt; of the lower level dependency (&lt;code&gt;B&lt;&#x2F;code&gt;) as &lt;em&gt;input&lt;&#x2F;em&gt; to the tested function (&lt;code&gt;A&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;Could we just rewrite the function? Instead of &lt;em&gt;calling&lt;&#x2F;em&gt; &lt;code&gt;B&lt;&#x2F;code&gt; directly for its output, &lt;code&gt;A&lt;&#x2F;code&gt; could just accept it
as an additional parameter? No, because &lt;code&gt;A&lt;&#x2F;code&gt; would then become a &lt;em&gt;utility&lt;&#x2F;em&gt;! There has to be &lt;em&gt;some code somewhere&lt;&#x2F;em&gt; that connects
the output of &lt;code&gt;B&lt;&#x2F;code&gt; to the input of &lt;code&gt;A&lt;&#x2F;code&gt;. We would see that &lt;code&gt;A&lt;&#x2F;code&gt; is on the call stack while &lt;code&gt;B&lt;&#x2F;code&gt; is executing. Therefore, it must be modelled
as a function call.&lt;&#x2F;p&gt;
&lt;p&gt;So the control flow goes from &lt;code&gt;A&lt;&#x2F;code&gt; to &lt;code&gt;B&lt;&#x2F;code&gt; and then back to &lt;code&gt;A&lt;&#x2F;code&gt;, with &lt;code&gt;B&lt;&#x2F;code&gt;&#x27;s answer. But only in release mode. In the unit test
we&#x27;d like to just specify what &lt;code&gt;B&lt;&#x2F;code&gt;s output is, we don&#x27;t want the call to happen for real. Something external to &lt;code&gt;A&lt;&#x2F;code&gt; needs to
specify whether the real call to &lt;code&gt;B&lt;&#x2F;code&gt; will happen or not. This is inversion of control (IoC).&lt;&#x2F;p&gt;
&lt;p&gt;There are different ways of implementing IoC. It can use function pointers, it can use method dispatch, it can use a special configuration parameter.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;dependency-injection&quot;&gt;Dependency Injection&lt;&#x2F;h4&gt;
&lt;p&gt;Dependency Injection (DI) is an implementation of IoC. It usually builds on some kind of method dispach. The &lt;code&gt;B&lt;&#x2F;code&gt; from before could be some
object named &lt;code&gt;b&lt;&#x2F;code&gt;, with the method &lt;code&gt;b&lt;&#x2F;code&gt;, so &lt;code&gt;A&lt;&#x2F;code&gt; could call &lt;code&gt;b.b()&lt;&#x2F;code&gt;, and since the method call is being dispatched, &lt;code&gt;A&lt;&#x2F;code&gt; has not hard-coded
its dependency. The &lt;em&gt;injection&lt;&#x2F;em&gt; is to pass a &lt;code&gt;B&lt;&#x2F;code&gt; &lt;em&gt;object instance&lt;&#x2F;em&gt; into &lt;code&gt;A&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;In modern field practice, dependencies are &lt;em&gt;code modules&lt;&#x2F;em&gt; with &lt;em&gt;dispatch functionality&lt;&#x2F;em&gt;. What I mean by that is that one &lt;code&gt;B&lt;&#x2F;code&gt; have many methods that
can be called, instead of just one. In strictly object oriented languages like Java, every function is part of a class, and most of them
are typically methods. Java has one class per file, so it will feel natural to put &lt;em&gt;related methods&lt;&#x2F;em&gt; inside &lt;em&gt;the same class&lt;&#x2F;em&gt;. Then it will also
feel natural to pass around instances of those classes to create dependency graphs.&lt;&#x2F;p&gt;
&lt;p&gt;I am not sure whether passing a function pointer would classify as DI.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;mocking&quot;&gt;Mocking&lt;&#x2F;h4&gt;
&lt;p&gt;Mocking, broadly, is the practice of injecting &lt;em&gt;test doubles&lt;&#x2F;em&gt; as surrogates for real dependencies when unit tests are executed.&lt;&#x2F;p&gt;
&lt;p&gt;Java&#x2F;JVM, which I&#x27;m most familiar with, has various mock libraries (Mockito, mockk, etc) that utilize reflection and runtime bytecode generation
to create alternative implementations based on &lt;em&gt;concrete classes&lt;&#x2F;em&gt; at &lt;em&gt;runtime&lt;&#x2F;em&gt;. That&#x27;s right, dependencies do not need to be abstract
interfaces for this to work.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;java-application-architecture&quot;&gt;Java application architecture&lt;&#x2F;h3&gt;
&lt;p&gt;Java was once purely Object Oriented, but has moved towards a more functional style in more recent years. Other, &amp;quot;secondary&amp;quot; JVM languages
have accelerated this move. But a typical modern Java (or Kotlin) program is still object oriented, and what I&#x27;m thinking of
is of course Dependency modelling, and all of the Domain-Driven-Design names of classes, like &lt;code&gt;FooController&lt;&#x2F;code&gt;, &lt;code&gt;FooService&lt;&#x2F;code&gt;
and &lt;code&gt;FooRepository&lt;&#x2F;code&gt;. There might be a setup like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;java&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-java &quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;FooController &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;FooService &lt;&#x2F;span&gt;&lt;span&gt;fooService;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; another file
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;FooService &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;FooRepository &lt;&#x2F;span&gt;&lt;span&gt;fooRepository;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is a dependency graph. The classes accept their dependencies as parameters in the constructor. In the running application,
they get instantiated once, and live for the rest of the program&#x27;s lifetime.&lt;&#x2F;p&gt;
&lt;p&gt;This architectural style is ubiquitous, it&#x27;s an industry standard and accepted best practice.&lt;&#x2F;p&gt;
&lt;p&gt;To recap:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Business logic calls are &lt;em&gt;dispatched&lt;&#x2F;em&gt; via a method call to through a reference to another class instance.&lt;&#x2F;li&gt;
&lt;li&gt;Utilities are just called&#x2F;instantiated direcly, no dispatch.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;java-testing&quot;&gt;Java testing&lt;&#x2F;h4&gt;
&lt;p&gt;Let&#x27;s look at the consequence of this pattern in unit tests. We want to &lt;em&gt;mock&lt;&#x2F;em&gt; dependencies.
We want to test a method of a class, and that class receives dependencies through its constructor.
There could be &lt;em&gt;many&lt;&#x2F;em&gt; dependencies, and since we run in a test, it&#x27;s common to mock out
those dependencies. For example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;java&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-java &quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;FooService&lt;&#x2F;span&gt;&lt;span&gt; service = new &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;FooService&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;    mock&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;BarService&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;(),
&lt;&#x2F;span&gt;&lt;span&gt;    mock&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;BazService&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;(),
&lt;&#x2F;span&gt;&lt;span&gt;    mock&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;QuxService&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;(),
&lt;&#x2F;span&gt;&lt;span&gt;    mock&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;WyfService&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;(),
&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I.e. we create 4 mock objects. So far so good, continuing with:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;java&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-java &quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt; output = service.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;someMethodThatWeWantToTest&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; assertEquals(42, output);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Does that method call use all those 4 dependencies? We don&#x27;t really know without looking at its implementation.
&lt;code&gt;FooService&lt;&#x2F;code&gt; could be a large class
with a hundred methods that are &amp;quot;somewhat related&amp;quot;. We still had to mock 4 dependencies.&lt;&#x2F;p&gt;
&lt;p&gt;Of those 4 dependencies, what &lt;em&gt;methods&lt;&#x2F;em&gt; of those dependencies are used within &lt;code&gt;someMethodThatWeWantToTest&lt;&#x2F;code&gt;
(There &lt;em&gt;could&lt;&#x2F;em&gt; be a hundred methods in each)?
Also not easy to know without looking at the actual implementation.&lt;&#x2F;p&gt;
&lt;p&gt;What we have is something that works OK, but in many cases look like over-abstractions, in my view.
I&#x27;m talking about the whole Dependency vs. method &lt;em&gt;inside&lt;&#x2F;em&gt; Dependency duality. In fact, it is the
&lt;em&gt;called methods&lt;&#x2F;em&gt; which are the &lt;strong&gt;real&lt;&#x2F;strong&gt; dependencies, not the class that contains those methods.
The dependency to the class instance may be seen as a &lt;em&gt;hack&lt;&#x2F;em&gt; to get method dispatch working.&lt;&#x2F;p&gt;
&lt;p&gt;But if Java didn&#x27;t do it that way, there would be 10 times more classes with just a single method
in each. And if you wanted to have a method that calls 10 other methods, you&#x27;d need to pass
10 different dependency references into it. And those things aren&#x27;t free!&lt;&#x2F;p&gt;
&lt;p&gt;We will see if it is possible to improve a bit on this when we come to the Rust section:&lt;&#x2F;p&gt;
&lt;h3 id=&quot;rust-application-architecture&quot;&gt;Rust application architecture&lt;&#x2F;h3&gt;
&lt;p&gt;Rust and the JVM languages have very different designs. In Java you can &amp;quot;hack&amp;quot; the language
during runtime to enable things that the language wasn&#x27;t really designed to do. Trying to do something
like that with Rust would be close to crazy. Rust has no reflection, so it is much
more limited in the things it might be able to infer during runtime. Rust only does exactly what the
code says, with very few exceptions.&lt;&#x2F;p&gt;
&lt;p&gt;That is not to say we cannot have IoC in Rust, we very much can, and the go-to language feature for
that is &lt;code&gt;trait&lt;&#x2F;code&gt;. In fact we can have zero-cost IoC. So whatever testing design we come up with, it should
not have performance impact on the finished product. We only pay for what we use, and
a release build does not include the tests.&lt;&#x2F;p&gt;
&lt;p&gt;Altough we can use traits to achieve IoC, it&#x27;s very much opt-in. A standard method call in Rust
is not dispatched. It&#x27;s only dispatched if some kind of &lt;em&gt;generics&lt;&#x2F;em&gt; are involved (a zero-cost
abstraction), and when &lt;code&gt;dyn&lt;&#x2F;code&gt; is used (which is not completely zero cost).&lt;&#x2F;p&gt;
&lt;h4 id=&quot;testing-philosophy-in-rust&quot;&gt;Testing philosophy in Rust&lt;&#x2F;h4&gt;
&lt;p&gt;I think that Rust codebases have traditionally leaned more upon integration testing than unit testing.
The unit tests that I tend to see there, are usually tests for &lt;em&gt;utilities&lt;&#x2F;em&gt;. Unit-testing
utilities is easy.&lt;&#x2F;p&gt;
&lt;p&gt;Business logic seems to get less attention. I don&#x27;t know the answer why, but it &lt;em&gt;might&lt;&#x2F;em&gt; be because
there aren&#x27;t any established design patterns.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;trying-to-port-the-oop-patterns-directly&quot;&gt;Trying to port the OOP patterns directly&lt;&#x2F;h4&gt;
&lt;p&gt;First, we can imagine something like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;FooController &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;handle_something&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is an interface that we need to implement for a type.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;FooController for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;FooControllerImpl &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;handle_something&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; ... the implementation
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Trying to model DI could look something like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;FooControllerImpl &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;foo_service&lt;&#x2F;span&gt;&lt;span&gt;: Box&amp;lt;dyn FooService&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;But I think there there are several code smells already.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;It&#x27;s not zero cost
&lt;ul&gt;
&lt;li&gt;It requires a heap allocation&lt;&#x2F;li&gt;
&lt;li&gt;It uses &lt;code&gt;dyn&lt;&#x2F;code&gt;, and therefore dynamic dispatch through a vtable.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;It looks Object Oriented, which is &lt;em&gt;probably&lt;&#x2F;em&gt; not the correct paradigm&lt;&#x2F;li&gt;
&lt;li&gt;It&#x27;s a little verbose, tedious to write.&lt;&#x2F;li&gt;
&lt;li&gt;It inherits the many-methods-in-many-dependencies design from OOP&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;To mitigate &lt;code&gt;1.&lt;&#x2F;code&gt;, we could make a static dispatch solution:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;FooControllerImpl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;F&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;foo_service&lt;&#x2F;span&gt;&lt;span&gt;: F,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;But Instead I really want to break this properly apart and try to lose all these &amp;quot;wannabe-class&amp;quot; things.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;modules&quot;&gt;Modules&lt;&#x2F;h4&gt;
&lt;p&gt;In Java, a code module&#x2F;file always equals a &lt;code&gt;class&lt;&#x2F;code&gt; which somehow needs to be instantiated. Rust just
has normal code modules, and you usually group together related types, impls, traits and functions
and put them in the same module. You don&#x27;t instantiate a Rust module.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;functions-or-methods&quot;&gt;Functions or methods?&lt;&#x2F;h4&gt;
&lt;p&gt;In Rust, it is not always clear whether you should make some computation a &lt;em&gt;function&lt;&#x2F;em&gt; or a &lt;em&gt;method&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;If it is very clear what the &lt;em&gt;subject&lt;&#x2F;em&gt; is that you are operating on, you should probably create a method.
But a design like the following will appear contrived to many Rust developers:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;FooServiceImpl &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;bar_service&lt;&#x2F;span&gt;&lt;span&gt;: ?
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;FooServiceImpl &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;do_something&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.bar_service.do_something_else();
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;BarServiceImpl &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;BarServiceImpl &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;do_something_else&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Types (&lt;code&gt;struct&lt;&#x2F;code&gt;, &lt;code&gt;enum&lt;&#x2F;code&gt;) should be used to represent the &lt;em&gt;data types&lt;&#x2F;em&gt; in the domain of the
application. A type like &lt;code&gt;FooServiceImpl&lt;&#x2F;code&gt; is no such thing, and my view is that these have no place
in a Rust program. I once developed a Rust application at work where I used a Service-oriented
design, and I wasn&#x27;t fond of the end result at all. It felt very unnatural to work with.
These OOP patterns just don&#x27;t tend to fit well with Rust.&lt;&#x2F;p&gt;
&lt;p&gt;I&#x27;d now like to introduce a design based on combining functions and traits, to achieve &lt;em&gt;static, zero-cost dependency injection&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zero-cost-di-with-functions-and-traits-the-deps-pattern&quot;&gt;zero-cost DI with functions and traits: The &lt;em&gt;&amp;quot;deps-pattern&amp;quot;&lt;&#x2F;em&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;The idea is that some function &lt;code&gt;a&lt;&#x2F;code&gt; has a generic parameter called &lt;code&gt;deps&lt;&#x2F;code&gt; that declares all its
dependencies as a union of trait bounds.&lt;&#x2F;p&gt;
&lt;p&gt;An abstract computation that can be depended upon is declared as a trait:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;B &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The function which depends on &lt;code&gt;B&lt;&#x2F;code&gt;, looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;deps&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;impl B) {
&lt;&#x2F;span&gt;&lt;span&gt;    deps.b();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;(&lt;code&gt;impl B&lt;&#x2F;code&gt; is a shorthand notation, it means being generic over some type that implements the trait &lt;code&gt;B&lt;&#x2F;code&gt;)&lt;&#x2F;p&gt;
&lt;p&gt;Expanding a bit, let&#x27;s write out the full declarations of both &lt;code&gt;A&lt;&#x2F;code&gt;  and &lt;code&gt;B&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;A &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;deps&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;impl B) {
&lt;&#x2F;span&gt;&lt;span&gt;    deps.b();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;B &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;deps&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;T) { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; (T is unbounded, as it&amp;#39;s not used)
&lt;&#x2F;span&gt;&lt;span&gt;    unimplemented!()
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;You will notice that the &lt;code&gt;fn a(&amp;amp;self)&lt;&#x2F;code&gt; in &lt;code&gt;A&lt;&#x2F;code&gt; and &lt;code&gt;fn a(deps: &amp;amp;impl B)&lt;&#x2F;code&gt; have similar signatures.
The difference between them is that the trait exports &lt;em&gt;itself&lt;&#x2F;em&gt; as a dependency, while the function is
the implementation of that, and declares its &lt;em&gt;own&lt;&#x2F;em&gt; dependencies.&lt;&#x2F;p&gt;
&lt;p&gt;There&#x27;s still something missing in this picture though, we don&#x27;t have a working application yet!
There is nothing that makes &lt;code&gt;a&lt;&#x2F;code&gt; &lt;em&gt;actually&lt;&#x2F;em&gt; call &lt;code&gt;b&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;To get there, we need a &lt;em&gt;type&lt;&#x2F;em&gt; which will implement both traits &lt;code&gt;A&lt;&#x2F;code&gt; and &lt;code&gt;B&lt;&#x2F;code&gt;, with those
implementations acting as the final &amp;quot;linking stage&amp;quot;, wiring together  &lt;code&gt;A&lt;&#x2F;code&gt; with &lt;code&gt;a&lt;&#x2F;code&gt; and &lt;code&gt;B&lt;&#x2F;code&gt; with &lt;code&gt;b&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Application &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; &amp;quot;state&amp;quot; the app needs to operate.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; configuration, connection pools, etc
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;A for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Application &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; call the _function_ a, defined above.
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; This compiles, because Application
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; also implements trait B.
&lt;&#x2F;span&gt;&lt;span&gt;        a(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;B for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Application &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; call the _function_ b
&lt;&#x2F;span&gt;&lt;span&gt;        b(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Neither of the global functions &lt;code&gt;a&lt;&#x2F;code&gt; nor &lt;code&gt;b&lt;&#x2F;code&gt; depend on the Application directly, just on
their immediate dependencies.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;Application&lt;&#x2F;code&gt; struct holds all the data the application needs to operate.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Leaf nodes&lt;&#x2F;em&gt; of the dependency graph will often require access to application state.
Examples of leaf operations could be performing a database operation, other kinds
of I&#x2F;O or provide some configuration parameter:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;GetApiUrl &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;get_api_url&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;str&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;GetApiUrl for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Application &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;get_api_url&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;str &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.config.api_url
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;FetchTodo &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;fetch_todo&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;id&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;u32&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Todo;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;fetch_todo&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;deps&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;impl GetApiUrl, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;id&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;u32&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Todo {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; url = deps.get_api_url();
&lt;&#x2F;span&gt;&lt;span&gt;    some_http_library.get(format!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;{url}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;&#x2F;posts&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;{id}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;FetchTodo for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Application &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;fetch_todo&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;id&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;u32&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Todo {
&lt;&#x2F;span&gt;&lt;span&gt;        fetch_todo(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, id)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;An example showing multiple dependencies:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;A &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;B &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;C &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;c&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;deps&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;impl B&lt;&#x2F;span&gt;&lt;span&gt; + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;C&lt;&#x2F;span&gt;&lt;span&gt;)) {
&lt;&#x2F;span&gt;&lt;span&gt;    deps.b();
&lt;&#x2F;span&gt;&lt;span&gt;    deps.c();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;generalizing-the-implementations&quot;&gt;Generalizing the implementations&lt;&#x2F;h4&gt;
&lt;p&gt;The drawback with having a type like &lt;code&gt;Application&lt;&#x2F;code&gt; used everywhere is that each trait implementation needs
to be aware of the final type that&#x27;s going to be used. This would make it a bit harder to modularize
an application into multiple crates, and &lt;code&gt;Application&lt;&#x2F;code&gt; should architecturally exist in one of the most downstream
crates.&lt;&#x2F;p&gt;
&lt;p&gt;Take a look at &lt;code&gt;A for Application&lt;&#x2F;code&gt; again:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;A for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Application &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        a(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This implementation contains no code that actually depends on &lt;code&gt;Application&lt;&#x2F;code&gt;. It just calls the generic function &lt;code&gt;a&lt;&#x2F;code&gt;.
The only reason &lt;code&gt;Application&lt;&#x2F;code&gt; is used here is that we need something to dispatch from in the first place. We should &lt;em&gt;generalize&lt;&#x2F;em&gt; these
implementations, so they can live in upstream crates!&lt;&#x2F;p&gt;
&lt;p&gt;In order to be able to mock our trait &lt;em&gt;and&lt;&#x2F;em&gt; use its real implementation, &lt;code&gt;A&lt;&#x2F;code&gt; must be implemented for two distinct types. Implementing
it specifically for a mock type and generally for every other type would be disallowed by Rust coherence rules.&lt;&#x2F;p&gt;
&lt;p&gt;What we need is a &lt;em&gt;Generic Implementation-Providing Smart Pointer™&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;ImplRef&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;t&lt;&#x2F;span&gt;&lt;span&gt;, T: ?Sized&amp;gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;t&lt;&#x2F;span&gt;&lt;span&gt; T);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Every crate would depend on a common micro-crate that just provides this type.
The impl of function &lt;code&gt;a&lt;&#x2F;code&gt;, as the trait &lt;code&gt;A&lt;&#x2F;code&gt;, depending on trait &lt;code&gt;B&lt;&#x2F;code&gt;, would then look like:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;t&lt;&#x2F;span&gt;&lt;span&gt;, T&amp;gt; A for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;ImplRef&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;t&lt;&#x2F;span&gt;&lt;span&gt;, T&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    where ImplRef&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;t&lt;&#x2F;span&gt;&lt;span&gt;, T&amp;gt;: B,
&lt;&#x2F;span&gt;&lt;span&gt;        T: Sync
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        a(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It&#x27;s implemented for &lt;em&gt;any&lt;&#x2F;em&gt; &lt;code&gt;T&lt;&#x2F;code&gt;! But what is &lt;code&gt;T&lt;&#x2F;code&gt;? &lt;code&gt;T&lt;&#x2F;code&gt; is the immutable state  of the appliction.&lt;&#x2F;p&gt;
&lt;p&gt;Now we can also write an &lt;code&gt;AsImpl&lt;&#x2F;code&gt; trait with an &lt;code&gt;as_impl&lt;&#x2F;code&gt; method that has a blanket impl for any type, so we could write this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;AppState &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; ... things go here
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;entry_point&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;state&lt;&#x2F;span&gt;&lt;span&gt;: AppState) {
&lt;&#x2F;span&gt;&lt;span&gt;    state
&lt;&#x2F;span&gt;&lt;span&gt;        .as_impl() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; -&amp;gt; ImplRef&amp;lt;&amp;#39;_, AppState&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;        .a(); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; Call trait method `A::a`, which again calls `fn a`
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;AppState&lt;&#x2F;code&gt; now gets generically &amp;quot;tunneled&amp;quot; through the system from the entry point
to dependency leaf nodes. We can &amp;quot;dig out&amp;quot; the AppState at the other side, keeping
the rest of the application generic:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;INeedAppState &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;i_need_app_state&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; non-generic function
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;i_need_app_state&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;app_state&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;AppState) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; lowest level of business logic,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; bottom of the call stack.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; From here, only utilities are used.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; e.g. a HTTP library
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;t&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; INeedAppState for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;ImplRef&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;t&lt;&#x2F;span&gt;&lt;span&gt;, AppState&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;i_need_app_state&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        i_need_app_state(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Having this impl in the leaf position, requires all of the application
to depend on &lt;code&gt;AppState&lt;&#x2F;code&gt;. But &lt;code&gt;ImplRef&lt;&#x2F;code&gt; can be &lt;em&gt;projected&lt;&#x2F;em&gt;, so we could
call into sub-crates of our application:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;i_need_app_state&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;app_state&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;AppState) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; Call into the &amp;quot;storage&amp;quot; module:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; This is now a new sub-entry-point.
&lt;&#x2F;span&gt;&lt;span&gt;    app_state
&lt;&#x2F;span&gt;&lt;span&gt;        .storage
&lt;&#x2F;span&gt;&lt;span&gt;        .as_impl()
&lt;&#x2F;span&gt;&lt;span&gt;        .fetch_something(); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; call into a deps-pattern subsystem
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;real-world-backend-application&quot;&gt;Real-world backend application&lt;&#x2F;h4&gt;
&lt;p&gt;Integrating the &amp;quot;deps-pattern&amp;quot; into a real world backend will be very easy.&lt;&#x2F;p&gt;
&lt;p&gt;We&#x27;ll use an &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;axum&#x2F;latest&#x2F;axum&#x2F;&quot;&gt;Axum&lt;&#x2F;a&gt; handler as an example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; app_state = Arc::new(AppState {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;* all the required configuration and state, etc *&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;});
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; axum_app = Router::new()
&lt;&#x2F;span&gt;&lt;span&gt;    .route(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, get(handler_as_entry_point))
&lt;&#x2F;span&gt;&lt;span&gt;    .layer(Extension(app_state));
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;handler_as_entry_point&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;    Extension(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;state&lt;&#x2F;span&gt;&lt;span&gt;): Extension&amp;lt;Arc&amp;lt;AppState&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    state
&lt;&#x2F;span&gt;&lt;span&gt;        .as_impl()
&lt;&#x2F;span&gt;&lt;span&gt;        .my_top_level_business_logic()
&lt;&#x2F;span&gt;&lt;span&gt;        .await
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note that in an &lt;code&gt;async&lt;&#x2F;code&gt; context, the deps-pattern wouldn&#x27;t be free, because
futures would need to be boxed since they are defined through a trait.
But fortunately, that is &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;91611&quot;&gt;soon about to change&lt;&#x2F;a&gt; for the better.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;conclusion-evaluating-the-deps-pattern&quot;&gt;Conclusion: Evaluating the deps-pattern&lt;&#x2F;h3&gt;
&lt;p&gt;We have managed to flatten our earlier dependency graph (which was based on
an &lt;em&gt;actual&lt;&#x2F;em&gt; in-memory graph of references) to something where the dependency
graph is just a compile-time concept.&lt;&#x2F;p&gt;
&lt;p&gt;We have gotten rid of unnecessary and contrived types from the application,
and can continue to model it with normal functions. We can have &lt;em&gt;high level&lt;&#x2F;em&gt;
business logic depend on &lt;em&gt;low level&lt;&#x2F;em&gt; business logic, and we have Inversion of Control
since it&#x27;s all based on trait bounds. And (almost) everything should be zero cost.&lt;&#x2F;p&gt;
&lt;p&gt;In unit tests, we can provide alternative implementations of the traits
depended upon.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;There is one great disadvantage though.&lt;&#x2F;em&gt; Can you guess it? It&#x27;s the verbosity and all the boilerplate code.
The final pattern that I present will solve that isssue. Yes,
it will involve the use of macros! And yes, that will be presented in the next post,
because this is the end of this one.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Hypp post mortem</title>
        <published>2022-04-27T00:00:00+00:00</published>
        <updated>2022-04-27T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://audunhalland.github.io/blog/hypp-post-mortem/" type="text/html"/>
        <id>https://audunhalland.github.io/blog/hypp-post-mortem/</id>
        
        <content type="html">&lt;p&gt;Last year I spent a lot of time trying to make a proof-of-concept Rust GUI&#x2F;web framework
called &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;audunhalland&#x2F;hypp&quot;&gt;Hypp&lt;&#x2F;a&gt;. It takes inspiration from
Svelte, and uses a complex procedural macro to define components.&lt;&#x2F;p&gt;
&lt;p&gt;I wanted to design a syntax that is a hybrid of HTML and Rust code,
and I think it succeds at some things and fails at others.&lt;&#x2F;p&gt;
&lt;p&gt;A code example taken from its &lt;code&gt;tests&lt;&#x2F;code&gt; directory:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;component! {
&lt;&#x2F;span&gt;&lt;span&gt;    Toggle(prop1: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span&gt;, prop2: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;str&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        toggled: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;handle_click&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.toggled = !*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.toggled;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;lt;div&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; prop1 {
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;lt;p&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;yep&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&#x2F;p&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;lt;&#x2F;div&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;lt;div&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;lt;button onClick={&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;::handle_click}&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; toggled {
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;Toggled&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;            } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;Not toggled&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;lt;&#x2F;button&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;lt;&#x2F;div&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Everything related to one reusable component is written within the proc macro &lt;code&gt;component&lt;&#x2F;code&gt;,
which enables the macro to make some wild optimizations.&lt;&#x2F;p&gt;
&lt;p&gt;First, an analysis of what this code means. At first we see a construct like
&lt;code&gt;Name(arguments...) { state_variables... }&lt;&#x2F;code&gt;. That&#x27;s the name of the component,
its parameters, and its internal state. Then there&#x27;s an &lt;code&gt;fn&lt;&#x2F;code&gt; definition which
is a callback function that can be used within the &lt;em&gt;body&lt;&#x2F;em&gt;, which is
the last main syntax element. The body is a markup template language, and
will look familiar to many.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-nice-features-in-hypp-that-i-actually-got-working&quot;&gt;The nice features in Hypp that I actually got working&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;nice-jsx-like-syntax-featuring-rust-keywords-in-markup-templates&quot;&gt;Nice JSX-like syntax featuring Rust keywords in markup templates&lt;&#x2F;h4&gt;
&lt;p&gt;The markup syntax supports &lt;code&gt;if&lt;&#x2F;code&gt;, &lt;code&gt;for&lt;&#x2F;code&gt; and &lt;code&gt;match&lt;&#x2F;code&gt;! It only needs to look at a
few things to know what kind of &amp;quot;element&amp;quot; something is. A &lt;code&gt;&amp;lt;&lt;&#x2F;code&gt;
starts some markup element expression. A known Rust keyword
starts some &amp;quot;evaluation&amp;quot; (conditional or repetition).
A &lt;code&gt;{&lt;&#x2F;code&gt; will start a string-evaluation expression. This means
that there is no awkward syntax to &amp;quot;escape out&amp;quot; to reach
evaluation mode, but it also requires &lt;em&gt;literal text&lt;&#x2F;em&gt; to be
&lt;code&gt;&amp;quot;double-quoted&amp;quot;&lt;&#x2F;code&gt;. In my opinion that syntax works out very nicely,
the code appears clean and readable.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;update-optimizations-and-data-flow-analysis&quot;&gt;Update optimizations and data-flow analysis&lt;&#x2F;h4&gt;
&lt;p&gt;When you create a new reactive GUI framework, you absolutely need to have all
the cool optimizations as selling points! Most optimizations in web frameworks
are of the form &lt;em&gt;don&#x27;t update DOM if nothing changed&lt;&#x2F;em&gt;. I went for an architecture
where I wanted to avoid comparing new&#x2F;old model values as much as possible.
Along with each passed parameter to a &lt;em&gt;redraw&lt;&#x2F;em&gt;-like instruction, Hypp sends
along whether some parameter has changed from the parent component to the child
component. The child component then tracks data flow from its input definitions
out to its leaf nodes where it passes those parameters on.&lt;&#x2F;p&gt;
&lt;p&gt;So a Hypp component makes a quick check at the start of its &lt;em&gt;update&lt;&#x2F;em&gt; procedure
to see which parts of its markup tree needs to be updated. Some parts of the
tree will be &lt;em&gt;constant&lt;&#x2F;em&gt;, i.e. they don&#x27;t depend on any variables. These parts
of the tree will only be created once, then never touched again. &lt;em&gt;Variable&lt;&#x2F;em&gt;
parts will get patched in and out between these constant parts.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;server-side-rendering&quot;&gt;Server side rendering&lt;&#x2F;h4&gt;
&lt;p&gt;From the start I designed Hypp with multiple backends in mind. I think that
turned out well.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;use-of-generic-associated-types&quot;&gt;Use of Generic Associated Types&lt;&#x2F;h4&gt;
&lt;p&gt;Hypp is GAT-heavy, and I utilized it to such a degree that I stumbled upon
several bugs in the Rust compiler, I even &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;pull&#x2F;89341&quot;&gt;fixed one&lt;&#x2F;a&gt;!&lt;&#x2F;p&gt;
&lt;p&gt;In the end though, I think I refactored the code so the fix wasn&#x27;t necessary for Hypp after all.
But I can definitely say that Hypp directly lead to actual improvements in the Rust language!&lt;&#x2F;p&gt;
&lt;h3 id=&quot;what-didn-t-work-so-well&quot;&gt;What didn&#x27;t work so well&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;too-much-macroifization&quot;&gt;Too much macroifization&lt;&#x2F;h4&gt;
&lt;p&gt;I don&#x27;t like that everything has to be inside one big macro. But I think it needs to,
to be able to see everything that&#x27;s part of the component at the same time. There
is a lot of analysis going on. All the conditionals and loops need to be translated
into a state machine, the component instances need to store all of this, along with
its input parameters. It needs to store its last input parameters in case it gets
a direct signal that it needs to update (e.g. an event happened like a button click).
In that case it may have to send those parameters to &lt;em&gt;child components&lt;&#x2F;em&gt; that were
potentially invisible (not instantiated) before that event.&lt;&#x2F;p&gt;
&lt;p&gt;The macro generates a &lt;em&gt;lot&lt;&#x2F;em&gt; of Rust code, more than I would have thought at first.
I put in significant effort to reduce every possible code duplications. Somehow
I don&#x27;t like that the component looks small and elegant expressed in surface syntax,
but compiles down to a monstrosity.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;event-propagation&quot;&gt;Event propagation&lt;&#x2F;h4&gt;
&lt;p&gt;I never got this part right. The problems with event handling can be found quite
easily in Hypp&#x27;s Todo example app. It gets into a never-ending update loop.&lt;&#x2F;p&gt;
&lt;p&gt;At this point I lost the motivation. It didn&#x27;t think it was fun anymore, there
were too much refactoring of everything everywhere just to make tiny adjustments.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;loose-ends-and-scope-of-project&quot;&gt;Loose ends and scope of project&lt;&#x2F;h4&gt;
&lt;p&gt;Hypp started out as a syntax experiment, and it escalated. I find meta-programming
too interesting.&lt;&#x2F;p&gt;
&lt;p&gt;A project like this can never really be &amp;quot;done&amp;quot; because its
scope is very hard to define. To take it somewhere remotely close to production quality
is way too big a task for a hobby project developed during the night.&lt;&#x2F;p&gt;
&lt;p&gt;It was (almost too much) fun while it lasted. My next projects will try to have a more
focused scope.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>The first blog post</title>
        <published>2022-04-25T00:00:00+00:00</published>
        <updated>2022-04-25T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://audunhalland.github.io/blog/first-post/" type="text/html"/>
        <id>https://audunhalland.github.io/blog/first-post/</id>
        
        <content type="html">&lt;p&gt;I decided to create a BLOG, and this is the first post in the blog.&lt;&#x2F;p&gt;
&lt;p&gt;I haven&#x27;t thought fully through what the blog will be about. Probably things
that I&#x27;m interested in, care and think about. Probably a large part of it
will be about computer programming.&lt;&#x2F;p&gt;
&lt;p&gt;I just made the big blog decision earlier today. But then I didn&#x27;t really know
what to do. I might be a professional software developer, but I&#x27;m not that
great at &lt;em&gt;web&lt;&#x2F;em&gt; things. I had heard about the JAM stack movement and statically
generated web pages, but I didn&#x27;t make the connection that I could actually build
a blog that way! A co-worker just told me. He listed up various framework
that can be used, and of course I went with the &lt;em&gt;blazing fast&lt;&#x2F;em&gt; Rust one: &lt;a href=&quot;https:&#x2F;&#x2F;getzola.org&quot;&gt;Zola&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;I have been a Rust user since 2016 when I first heard about the language.
Sometimes at work, but mostly personal projects. Even though I probably
spend most of my time with other languages, I now consider Rust my &amp;quot;main&amp;quot; language.
There could be many reasons for that. I enjoy efficient execution, probably
because of my background in C&#x2F;C++ and mobile&#x2F;embedded. Rust is an intriguing
language to use. There are &lt;em&gt;constraints&lt;&#x2F;em&gt;, it&#x27;s limiting my inner desire
to make silly, short-sighted design choices. Other languages mostly feel easy to
master, but Rust is a continuous learning experience. But this is why I love it,
its excellence in closely modelling the complex craft that programming really is,
and that you can&#x27;t ever &lt;em&gt;really&lt;&#x2F;em&gt; abstract away.&lt;&#x2F;p&gt;
&lt;p&gt;So this blog will likely have some Rust content in it. Maybe it will contain
something about music too. Playing, creating and listening to (mostly old) music is my
other passion. Perhaps I will import some things written on other blogging platforms
into this blog. Those posts will then predate this post, but this is still the
first post of &lt;em&gt;this&lt;&#x2F;em&gt; blog!&lt;&#x2F;p&gt;
&lt;p&gt;Next I&#x27;ll likely have to make some theme adjustments, even though I promised myself
I wasn&#x27;t going to care about the visual style of the blog.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>JSON — the relational database’s built-in ORM?</title>
        <published>2020-11-20T00:00:00+00:00</published>
        <updated>2020-11-20T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://audunhalland.github.io/blog/json-the-relational-databases-built-in-orm/" type="text/html"/>
        <id>https://audunhalland.github.io/blog/json-the-relational-databases-built-in-orm/</id>
        
        <content type="html">&lt;p&gt;&lt;em&gt;originally posted on &lt;a href=&quot;https:&#x2F;&#x2F;knowitlabs.no&#x2F;json-the-relational-databases-built-in-orm-965bd0905f4d&quot;&gt;Knowitlabs&lt;&#x2F;a&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Database code. Queries, updates, and deletes. Repositories. Like many other developers, I have struggled with these things that tend to end up rather ugly. Not only might there be a lot of programming language (SQL) embedded inside another programming language (your app’s code), but there are a lot of mappings back and forth for data types, integration code, boilerplate! Or, you might be one of the lucky ones who get to use an Object Relational Mapping-library, clean, simple, and elegant code, right, hiding all of the interesting details? This post is about the quest for the Right Abstraction.&lt;&#x2F;p&gt;
&lt;p&gt;I’ve used two different relational databases professionally, first SQLite, and then PostgreSQL. I don’t consider myself very experienced in writing database code, but I do think that working with databases is one of the more enjoyable parts of being a developer. Except for that damn mapping code. In my first job, I used an in-house-developed ORM for SQLite, that needed constant modifications to be able to cope with the ever-growing complexity of queries coming from the layers above. ORM development tends to start out very simple: &lt;em&gt;right now I just need to read this or that table as a list&lt;&#x2F;em&gt;. But soon we need foreign keys and querying for trees, and before you know it you’ve reimplemented all the features of SQL itself. Just a lot worse, and what a mess you’re now in.&lt;&#x2F;p&gt;
&lt;p&gt;I &lt;em&gt;like&lt;&#x2F;em&gt; working with different languages, they exist for a reason, I believe that SQL was designed to be written by humans instead of being a compiler target. I want to use all the cool features from my specific database implementation, and a general-purpose db-agnostic ORM might not support everything.&lt;&#x2F;p&gt;
&lt;p&gt;So I prefer writing out my SQL statements, but what about the “mapping” code?&lt;&#x2F;p&gt;
&lt;p&gt;Let’s start with a simple problem that might seem unrelated at first, with the usual boring tables:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sql&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-sql &quot;&gt;&lt;code class=&quot;language-sql&quot; data-lang=&quot;sql&quot;&gt;&lt;span&gt;CREATE TABLE &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;customer
&lt;&#x2F;span&gt;&lt;span&gt;    id UUID &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;PRIMARY KEY &lt;&#x2F;span&gt;&lt;span&gt;NOT NULL,
&lt;&#x2F;span&gt;&lt;span&gt;    name &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;TEXT&lt;&#x2F;span&gt;&lt;span&gt;;CREATE TABLE &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;order
&lt;&#x2F;span&gt;&lt;span&gt;    id UUID &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;PRIMARY KEY &lt;&#x2F;span&gt;&lt;span&gt;NOT NULL,
&lt;&#x2F;span&gt;&lt;span&gt;    customer_id UUID NOT NULL &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;REFERENCES&lt;&#x2F;span&gt;&lt;span&gt; customer (id),
&lt;&#x2F;span&gt;&lt;span&gt;    description &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;TEXT&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The task at hand is to query for all customers and all orders for each customer (yes, I want it to be structured). There are several ways to do that. Often, to keep things very simple, the solution might be to issue &lt;a href=&quot;https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;97197&#x2F;what-is-the-n1-selects-problem-in-orm-object-relational-mapping&quot;&gt;N+1&lt;&#x2F;a&gt; separate queries:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sql&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-sql &quot;&gt;&lt;code class=&quot;language-sql&quot; data-lang=&quot;sql&quot;&gt;&lt;span&gt;SELECT id, name FROM customer;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;followed by&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sql&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-sql &quot;&gt;&lt;code class=&quot;language-sql&quot; data-lang=&quot;sql&quot;&gt;&lt;span&gt;SELECT id, description
&lt;&#x2F;span&gt;&lt;span&gt;FROM order
&lt;&#x2F;span&gt;&lt;span&gt;WHERE customer_id = $customer_id;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;issued for each of those initial rows. But this usually leads to performance issues because of missed optimization opportunities by the RDBMS, so I think we can do better.&lt;&#x2F;p&gt;
&lt;p&gt;Let’s leave that thought for a while and go back to the problem of deserializing rows into something that’s nice to work within my programming language of choice. For a &lt;em&gt;customer&lt;&#x2F;em&gt;, we usually want some kind of object having the fields &lt;code&gt;id&lt;&#x2F;code&gt; and &lt;code&gt;name&lt;&#x2F;code&gt;. A mapper, in pseudocode, could look like:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;javascript&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-javascript &quot;&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;function &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;row_to_customer&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;row&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;Customer&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;id &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;row&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;id&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;name &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;row&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;])
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;That’s the type of boilerplate I don’t like writing. But it’s deserialization, and there’s one serialization format that any programming language will be able to deserialize for you (with hopefully very little boilerplate), and that’s &lt;em&gt;JSON&lt;&#x2F;em&gt;. These days I’m mostly using PostgreSQL and it has good support for JSON, and others have too. Let’s rewrite our query:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sql&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-sql &quot;&gt;&lt;code class=&quot;language-sql&quot; data-lang=&quot;sql&quot;&gt;&lt;span&gt;SELECT
&lt;&#x2F;span&gt;&lt;span&gt;    json_build_object(
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;id&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;, id,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;, name
&lt;&#x2F;span&gt;&lt;span&gt;    )
&lt;&#x2F;span&gt;&lt;span&gt;FROM customer;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And just throw each row at our JSON deserializer, then there’s (almost) no mapping code to write anymore.&lt;&#x2F;p&gt;
&lt;p&gt;Our initial case with a list of orders for each customer, JSON solves that quite easily as well:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sql&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-sql &quot;&gt;&lt;code class=&quot;language-sql&quot; data-lang=&quot;sql&quot;&gt;&lt;span&gt;SELECT
&lt;&#x2F;span&gt;&lt;span&gt;    json_build_object(
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;id&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;, id,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;, name,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;orders&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;, (
&lt;&#x2F;span&gt;&lt;span&gt;             SELECT
&lt;&#x2F;span&gt;&lt;span&gt;                 json_agg(
&lt;&#x2F;span&gt;&lt;span&gt;                     json_build_object(
&lt;&#x2F;span&gt;&lt;span&gt;                         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;id&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;, id
&lt;&#x2F;span&gt;&lt;span&gt;                         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;description&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;, description
&lt;&#x2F;span&gt;&lt;span&gt;                     )
&lt;&#x2F;span&gt;&lt;span&gt;                     ORDER BY description
&lt;&#x2F;span&gt;&lt;span&gt;                 )
&lt;&#x2F;span&gt;&lt;span&gt;             FROM order
&lt;&#x2F;span&gt;&lt;span&gt;             WHERE &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;order&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;customer_id &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;customer&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;id
&lt;&#x2F;span&gt;&lt;span&gt;        )
&lt;&#x2F;span&gt;&lt;span&gt;    )
&lt;&#x2F;span&gt;&lt;span&gt;FROM customer;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;json_agg&lt;&#x2F;code&gt; will produce a nested list inside the outer object containing the rows of the subquery, and we’re done, without any additional mapping code, except the language-specific hints potentially needed to deserialize this into the object:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;java&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-java &quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;CustomerWithOrders &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    id: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;UUID&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    name: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;String&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    orders: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Array&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Order&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I’ve used the JSON&#x2F;SQL technique with great success lately, especially for queries that involve querying many tables where a single big, fat old JOIN won’t cut it. It’s very fast: The database is allowed to do its own optimizations, and JSON is usually extremely fast to process by the application.&lt;&#x2F;p&gt;
&lt;p&gt;Could we try a similar thing for insertion?&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sql&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-sql &quot;&gt;&lt;code class=&quot;language-sql&quot; data-lang=&quot;sql&quot;&gt;&lt;span&gt;INSERT INTO order (customer_id, description)
&lt;&#x2F;span&gt;&lt;span&gt;    VALUES (
&lt;&#x2F;span&gt;&lt;span&gt;       ($&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;customer_id&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;)::UUID,
&lt;&#x2F;span&gt;&lt;span&gt;       $&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;description&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;    );
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now you only have to bind one parameter instead of two and avoid at least one level of Repeating Yourself.&lt;&#x2F;p&gt;
&lt;p&gt;Is it fair to call this the &lt;em&gt;database’s built-in ORM&lt;&#x2F;em&gt;? We used json_build_&lt;strong&gt;object&lt;&#x2F;strong&gt;, right? Seriously, I’m not sure, but it was a fun thought anyway.&lt;&#x2F;p&gt;
&lt;p&gt;I hope you learned a useful programming pattern, at least it took a while for me to discover it.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Rust 2020: Testing</title>
        <published>2019-11-29T00:00:00+00:00</published>
        <updated>2019-11-29T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://audunhalland.github.io/blog/rust-2020-testing/" type="text/html"/>
        <id>https://audunhalland.github.io/blog/rust-2020-testing/</id>
        
        <content type="html">&lt;p&gt;&lt;em&gt;originally posted on &lt;a href=&quot;https:&#x2F;&#x2F;knowitlabs.no&#x2F;rust-2020-testing-4ab3d80112ba&quot;&gt;Knowitlabs&lt;&#x2F;a&gt;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Unit testing. Becoming a master of any programming language totally depends on also mastering its testing tools. Having tests in the code base in the first place increases the overall functional code quality, but when we go a step further and write isolated tests, this also enforces various desirable constraints on our code structure. The call graphs&#x2F;external dependency graphs of components that are tested in isolation are much easier to reason about. The result is better overall code structure.&lt;&#x2F;p&gt;
&lt;p&gt;Before our team chose to develop a new application using Rust, I had some experience using various degrees of test driven development styles in Python, Spring Boot (JUnit) and node.js (jest). I am by no means an expert at test writing, having adopted this style of development only the last 2–3 years. Projects I worked on before that did not rely as much on TDD, but more on “stunt programming” — let’s just say that I try to be a good professional now.&lt;&#x2F;p&gt;
&lt;p&gt;In this article I’ll write a little about the way I currently think about testing, and then about implementing these ideas in Rust. &lt;strong&gt;TL;DR&lt;&#x2F;strong&gt;: Not everything works as smoothly as when working with higher level languages, maybe unsurprisingly.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;code-decoupling&quot;&gt;Code decoupling&lt;&#x2F;h3&gt;
&lt;p&gt;To be able to unit test our code (in isolation!) we can follow the design principle of writing loosely coupled code. The code components simply have to be loosely coupled to its dependencies in order for the latter to be controlled in isolated tests. I will get back to why loose coupling is a little more inconvenient to achieve in Rust than in higher-level languages. But first there are different degrees of loose coupling I want to mention, and they will hopefully help to illustrate my points later in the article: 1) Loose coupling for runtime reasons. 2) Loose coupling for testtime reasons. 3) Loose coupling for loose coupling reasons (I will not discuss 3) because I think it is absurd).&lt;&#x2F;p&gt;
&lt;p&gt;I personally think that the way components are decoupled should be done with its primary intent in mind. A de-coupling that enables a runtime abstraction in release mode should be syntactically and semantically more decoupled than a decoupling that just enables dependency control during test.&lt;&#x2F;p&gt;
&lt;p&gt;Let’s look at some decoupling techniques that I know of. Because this article is about testing, I’m thinking about all of these as means to control dependencies during test time.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;higher-order-functions&quot;&gt;Higher order functions&lt;&#x2F;h4&gt;
&lt;p&gt;If I want to test a function or procedure &lt;code&gt;A&lt;&#x2F;code&gt; in isolation that depends on another function &lt;code&gt;B&lt;&#x2F;code&gt;, I can pass &lt;code&gt;B&lt;&#x2F;code&gt; as a parameter to &lt;code&gt;A&lt;&#x2F;code&gt;. In production code I call &lt;code&gt;A(B)&lt;&#x2F;code&gt;. In the test I call &lt;code&gt;A(mocked_B)&lt;&#x2F;code&gt;, now with full control over that dependency.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;object-oriented-interface&quot;&gt;Object oriented “interface”&lt;&#x2F;h4&gt;
&lt;p&gt;If A has more than one logical dependency, the signature of the function will have more arguments, and the code will not look as clean. If some of the dependencies are fairly cohesive, we can group several of the dependencies together in an object oriented interface: &lt;code&gt;B.foo()&lt;&#x2F;code&gt; and &lt;code&gt;B.bar()&lt;&#x2F;code&gt;, where the actual implementation of foo and bar is determined by the concrete type of B, which will be a so-called mock object at test time. Good test tools provide us with ways to quickly configure these mocked functions (or methods), e.g. verifying how many times they are called in the test, recording their input arguments for later verfication or configuring return values.&lt;&#x2F;p&gt;
&lt;p&gt;Within my team it has been debated whether the best style is to exclusively depend on abstract interfaces, everywhere. My personal view is that this should be determined by the &lt;em&gt;runtime intent&lt;&#x2F;em&gt;. In high level languages this is usually no problem, because method dispatch is usually dynamic dy default. This means that any or most concrete types or classes are easily sub-classable, and thus the coupling to such a class by name is not really that strong under the hood. All python&#x2F;Java&#x2F;Kotlin&#x2F;JS languages support this easily: Creating mocks of concrete types.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;module-mocks&quot;&gt;Module mocks&lt;&#x2F;h4&gt;
&lt;p&gt;There may be of course be many, but Jest is the only testing framework I have seen where it is possible (and fully supported) to mock out entire code modules. You write your module-under-test with all external module dependencies in-place, all imported very directly. In JavaScript, the value of an imported code module is really an object with methods on it, so it’s really no surprise that this can work. Module mocking in jest works by reconfiguring which file the module is loaded from, and the overridden module is active for all tests defined in the same test file. Because a module import is a global “destructive”&#x2F;permanent operation, each Jest test suite is executed in a sandboxed environment to avoid interfering with other module mock configurations (or non-mocks) elsewhere in the code base.&lt;&#x2F;p&gt;
&lt;p&gt;This technique has the most implicit decoupling. It does not clutter business logic with phony quasi-abstraction-objects (service objects or what you may happen to call them). Another advantageous pattern that can emerge from this is that as more code is tested, modules will sometimes need to be refactored to be able to mock at the correct level for each test. The end result might be better overall module cohesion.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;rust&quot;&gt;Rust&lt;&#x2F;h2&gt;
&lt;p&gt;Rust is a different beast compared to the aforementioned languages. Being a system language focused on bare metal performance, abstractions do not “come for free”. At least not the ones I’m interested in here. First of all, all function calls are by default dispatched statically. This means that code calling another function directly is compiled into calling the exact implementation of that function, and not by a variable or table lookup. This is true also when calling regular methods of concrete types — struct methods are not overridable.&lt;&#x2F;p&gt;
&lt;p&gt;The two first techniques mentioned above can be applied perfectly fine in Rust, but there is a lot more for the developer to consider (and write!) in each case. The first thing to consider when introducing an abstraction is whether to use static or dynamic method dispatch. Static dispatch is related to monomorphization and generics. It means that a function A calling into an unknown function B is only lazily compiled — only when a call to some concrete B is known does the compiler emit code for A calling that exact B. This behaviour is optional, and we may choose to do dynamic dispatch instead, either by using a function pointer or by using a trait object, a way to call trait methods using a virtual lookup table passed along with the data pointer to the object instance.&lt;&#x2F;p&gt;
&lt;p&gt;So the way to express an abstraction in Rust is to use a trait. Trait mocking in Rust today is fairly developer friendly, but not as friendly as in dynamic-dispatch-languages. What I’ve been doing so far is to introduce a new trait everywhere I need test isolation, and use the crate mockall to autogenerate a mocked implementation that I instantiate in my test. Not very far from how java&#x2F;mockito or jest works, except that, as mentioned, we always need to be very explicit about the abstraction taking place:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;cfg_attr&lt;&#x2F;span&gt;&lt;span&gt;(test, mockall::automock)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;SomethingIWantToMock &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;mockable&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;ConcreteSomethingUsedInProduction &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;SomethingIWantToMock for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;ConcreteSomethingUsedInProduction &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;mockable&lt;&#x2F;span&gt;&lt;span&gt;() { ... }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;test&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;test_something&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; mock_something = MockSomethingIWantToMock::new();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; test some code using that dependency
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In Rust, making code dynamic dispatch is less verbose than making it static dispatch. This is in some ways counterintuitive, because in other areas of the language it appears to be a concious decision that less verbose code is simpler and therefore more efficient. Heap allocation is one example, it is always very apparent that a heap allocation will take place: Box&lt;MyThing&gt; instead of MyThing. A heap allocation is more expensive to type and execute. It seems concious that there is no short hand for this. First consider dynamic dispatch:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;dyn B) {
&lt;&#x2F;span&gt;&lt;span&gt;    b.b();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;where B is the trait a is abstract over. Now the static dispatch version of the above:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T: B&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;: T) {
&lt;&#x2F;span&gt;&lt;span&gt;    b.b();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; or alternatively
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;: T) where T: B {
&lt;&#x2F;span&gt;&lt;span&gt;    b.b();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To make the function abstract with static dispatch (not losing runtime performance), we needed to introduce two new names. First &lt;code&gt;B&lt;&#x2F;code&gt; for the trait itself, and then the name &lt;code&gt;T&lt;&#x2F;code&gt; that represents its concrete type when a is monomorphized over it.&lt;&#x2F;p&gt;
&lt;p&gt;Generic code can be a lot of fun to write, but I wouldn’t like it if my codebase is full of it just for test isolation purposes. I want my business logic to be clear and readable when it does concrete things — generic code mostly belongs in utilities. And in principle, I don’t want to make all my code dynamic dispatch just because I want to test it. For all I know the code could be a really performance critical hot path in my application. And I did choose to write it in Rust in the first place.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;module-mocks-in-rust&quot;&gt;Module mocks in Rust&lt;&#x2F;h3&gt;
&lt;p&gt;How nice would it be to have module mocks in Rust? My very first thought was that it sounds technically infeasible. All tests in Rust run in a thread pool. In Rust it is forbidden to mutate global state, with good reason. There’s no sandboxing environment like in Jest. All mocked module functions would need to implicitly take a hidden argument — or the whole test executable would need to be “monomorphized” for each individual test case, effectively leading to N copies of the program where N is the number of tests…&lt;&#x2F;p&gt;
&lt;p&gt;But it turns out you can still do this, using the nightly compiler! Enter Mocktopus, a module-level mocking library. Using a macro to transform a module definition, mocktopus turns any public function in that module into a mockable by rewriting its definition into first checking (at call time) if a function pointer has been registered, which is stored in a thread-local lookup table. The macro only takes effect in a test build, not in debug or release. I think this technique could fit well with our project, but trying to be somewhat serious we will not depend on experimental nightly-only Rust features.&lt;&#x2F;p&gt;
&lt;p&gt;Unfortunately, my current solution is that I do not try to make my tests isolated where it is not strictly needed for correctness or where it would lead to awkward-to-read business logic code. The consequence of this is that many places in the code I essentially test the same thing over and over again. But this is also due to a completely different (slight) shortcoming in the Rust testing ecosystem: The basic assertion macros.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;assertion-macros&quot;&gt;Assertion macros&lt;&#x2F;h3&gt;
&lt;p&gt;My test assertions are exclusively variations of &lt;code&gt;assert_eq!&lt;&#x2F;code&gt; and &lt;code&gt;assert_ne!&lt;&#x2F;code&gt;. There are assertion utility libraries that one could pull in, but none of them seem to be very widely used, there is no clear adopted industry standard on top of std::assert. Let’s go through some very simple code to highlight the slight inconvenience:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Answer &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span&gt;: Vec&amp;lt;String&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;bar&lt;&#x2F;span&gt;&lt;span&gt;: Vec&amp;lt;String&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;compute_answer&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;some_input&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;str&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Answer {
&lt;&#x2F;span&gt;&lt;span&gt;    Answer {
&lt;&#x2F;span&gt;&lt;span&gt;        foo: some_input.split(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;        bar: external_module::compute_bar(some_input)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Testing this function in isolation is the same as checking if the input string is split correctly. The test of external_module belongs in a different file, so we should ignore the value of bar in our test. But:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;test&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;test&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    assert_eq!(
&lt;&#x2F;span&gt;&lt;span&gt;        compute_answer(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;input.string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;        Answer {
&lt;&#x2F;span&gt;&lt;span&gt;            foo: vec![&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_string(), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_string()],
&lt;&#x2F;span&gt;&lt;span&gt;            bar: vec![&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    );
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;using &lt;code&gt;assert_eq!&lt;&#x2F;code&gt; I have to compare the full struct. Of course I could compare the member(s) explicitly:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;test&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;test&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; aswer = compute_answer(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;input.string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    assert_eq!(
&lt;&#x2F;span&gt;&lt;span&gt;        answer.foo,
&lt;&#x2F;span&gt;&lt;span&gt;        vec![&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_string(), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_string()],
&lt;&#x2F;span&gt;&lt;span&gt;    );
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;but it’s not as elegant as having a single matching expression for the whole type that I’m testing. But what if there was a macro for matching only what I care about? Let’s try the &lt;code&gt;assert_matches!&lt;&#x2F;code&gt; macro from the &lt;code&gt;matches&lt;&#x2F;code&gt; crate, a macro that makes it possible to assert that something matches a pattern similar to a match expression:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;test&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;test&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    assert_matches!(
&lt;&#x2F;span&gt;&lt;span&gt;        compute_answer(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;input.string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;        Answer {
&lt;&#x2F;span&gt;&lt;span&gt;            foo: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; Does not compile
&lt;&#x2F;span&gt;&lt;span&gt;            bar: _, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; Actually works!
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    );
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;AFAIK it’s not possible to match a struct deeply like this, because directly matching a Vec to a slice pattern does not work. Only things that are already slices may be pattern matched, and the members of Answer are not slices but Vecs, and not coerced.&lt;&#x2F;p&gt;
&lt;p&gt;My point with looking at assertion macros? Even if I might not be fully able to isolate everything my module-under-test does, I hoped that it would be straight-forward and elegant to at least only match the part of the output that I care about. It is a pattern I often use in jest: &lt;code&gt;expect(actual).toMatchObject({…})&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;I actually haven’t had a hard time at all “selling in” Rust for projects that would normally have been written in JVM or node.js. We’ve all been there complaining about the unstoppable memory-hunger and crazy slow Boot of Spring Boot. We are making web applications, and the problem space is usually in the high-level domain. Developers working with domains of a similar level are spoiled with good testing tools because their traditional languages of choice are also high level. Rust finally gives us a viable way to solve high level problems using a low level language—runtime-bloat-be-gone. But Rusts current testing story will be harder to sell to the TDD purists.&lt;&#x2F;p&gt;
&lt;p&gt;For 2020, I think the Rust community should make awesome, intuitive, complete, and well documented testing a priority. I don’t know how. But Rust has already managed to overcome so many unbelievable obstacles—just the feeling of using a high level language when you’re not really — this blows my mind. Now let’s make testing a killer product too.&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
