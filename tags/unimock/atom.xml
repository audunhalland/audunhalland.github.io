<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>Audun Halland - unimock</title>
    <subtitle>My home on the internet</subtitle>
    <link href="https://audunhalland.github.io/tags/unimock/atom.xml" rel="self" type="application/atom+xml"/>
    <link href="https://audunhalland.github.io"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2024-04-26T00:00:00+00:00</updated>
    <id>https://audunhalland.github.io/tags/unimock/atom.xml</id>
    <entry xml:lang="en">
        <title>Unimock 0.6: Mutation patterns</title>
        <published>2024-04-26T00:00:00+00:00</published>
        <updated>2024-04-26T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://audunhalland.github.io/blog/unimock-0-6/" type="text/html"/>
        <id>https://audunhalland.github.io/blog/unimock-0-6/</id>
        
        <content type="html">&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;unimock&#x2F;0.6&#x2F;unimock&#x2F;index.html&quot;&gt;Unimock 0.6&lt;&#x2F;a&gt; is just out, with an important change in design which makes it much more powerful than before.&lt;&#x2F;p&gt;
&lt;p&gt;The previous version (0.5) added support for parameter mutation, but it was quite limited.
The reason for the limitation was an inferior design that took a significant amount of trial and error to finally fix.
In hindsight it might seem obvious, but for some reason it wasn&#x27;t to me.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;TL;DR&lt;&#x2F;em&gt;: Unimock&#x27;s &lt;code&gt;answers&lt;&#x2F;code&gt; API is now based on an associated type instantiated to a &lt;code&gt;dyn Fn&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;background&quot;&gt;Background&lt;&#x2F;h2&gt;
&lt;p&gt;Unimock allows developers to define flexible one-off verifiable trait implementations with very little code&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;unimock&lt;&#x2F;span&gt;&lt;span&gt;(api = SomeTraitMock)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;SomeTrait &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;my_func&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; u = Unimock::new(
&lt;&#x2F;span&gt;&lt;span&gt;    SomeTraitMock::my_func
&lt;&#x2F;span&gt;&lt;span&gt;        .next_call(matching!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;42&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;        .returns(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;assert_eq!(u.my_func(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;42&lt;&#x2F;span&gt;&lt;span&gt;), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It also supports invoking a user-supplied function to compute the output dynamically:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; u = Unimock::new(
&lt;&#x2F;span&gt;&lt;span&gt;    SomeTraitMock::my_func
&lt;&#x2F;span&gt;&lt;span&gt;        .next_call(matching!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;42&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;        .answers(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;| input * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; &amp;lt;-- note: The old 0.5 API
&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;assert_eq!(u.my_func(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;42&lt;&#x2F;span&gt;&lt;span&gt;), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;84&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;But a problem appeared when I wanted to provide a mock integration for e.g. &lt;code&gt;Display&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Display &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;fmt&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span&gt;Formatter&amp;lt;&amp;#39;_&amp;gt;) -&amp;gt; Result&amp;lt;(), Error&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;Display&lt;&#x2F;code&gt; implementors supply behaviour by interacting with the mutable parameter &lt;code&gt;f&lt;&#x2F;code&gt;.
The return value is only used for reporting errors, and can be considered secondary.&lt;&#x2F;p&gt;
&lt;p&gt;As soon as the &lt;code&gt;answers&lt;&#x2F;code&gt; function needed to mutate parameters, it ran into problems with the type system.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-old-0-5-model&quot;&gt;The old 0.5 model&lt;&#x2F;h2&gt;
&lt;p&gt;Unimock&#x27;s function model was loosely based on a trait like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;MockFn &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Inputs&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;i&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; &amp;#39;i = lifetime of borrowed values in an inputs tuple
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Output&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;u&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; &amp;#39;u = lifetime of output borrowed from Self
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Using this model, it is quite easy to define a function bound like &lt;code&gt;Fn(F::Inputs&amp;lt;&#x27;i&amp;gt;) -&amp;gt; F::Output&amp;lt;&#x27;u&amp;gt;&lt;&#x2F;code&gt;.
But as soon as mutation is involved, this signature is not going to cut it, because the set of involved lifetimes is not finite anymore.&lt;&#x2F;p&gt;
&lt;p&gt;Version 0.5 ended up using a hack where &lt;em&gt;one&lt;&#x2F;em&gt; parameter could be mutated.
That &lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt; parameter (if present) was excluded from the the &lt;code&gt;Inputs&amp;lt;&#x27;i&amp;gt;&lt;&#x2F;code&gt; tuple, and handled completely separately from all other inputs.
This meant that it wasn&#x27;t possible to use the &lt;code&gt;matching!&lt;&#x2F;code&gt;-macro on that parameter.
The &lt;code&gt;matching&lt;&#x2F;code&gt; macro operates on immutable views of the function inputs, where a single, common lifetime parameter cuts it (because matching only reads things and does not return anything).&lt;&#x2F;p&gt;
&lt;p&gt;Given these limitations it became clear that this wasn&#x27;t very &lt;em&gt;developer friendly&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;0-6-a-better-model-for-mutation-patterns&quot;&gt;0.6: A better model for mutation patterns&lt;&#x2F;h2&gt;
&lt;p&gt;After trying many experiments with several predefined possibly-used GAT-lifetimes, I was ready to give up after hitting Rust limitations like not being able to sepcify outlives-bounds involving higher-ranked lifetimes (&lt;code&gt;for&amp;lt;&#x27;a, &#x27;b&amp;gt; where &#x27;b: &#x27;a&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;Then it occured to me that it&#x27;s possible to take advantage of the compiler&#x27;s builtin syntax to express exactly what is needed using &lt;em&gt;implied bounds&lt;&#x2F;em&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;b&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; Fn(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;a i32&lt;&#x2F;span&gt;&lt;span&gt;, &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;b mut &lt;&#x2F;span&gt;&lt;span&gt;Foo&amp;lt;&amp;#39;_&amp;gt;) -&amp;gt; Bar&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;Fn&lt;&#x2F;code&gt; &lt;em&gt;syntax family&lt;&#x2F;em&gt; expresses this perfectly, but what the &lt;code&gt;MockFn&lt;&#x2F;code&gt; trait needs is an associated &lt;em&gt;type&lt;&#x2F;em&gt;, not another trait bound (the &lt;code&gt;MockFn&lt;&#x2F;code&gt; is implemented for different function signatures!).&lt;&#x2F;p&gt;
&lt;p&gt;The answer to that is to use &lt;code&gt;dyn Fn&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Display &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;fmt&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span&gt;Formatter&amp;lt;&amp;#39;_&amp;gt;) -&amp;gt; Result&amp;lt;(), Error&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; #[unimock]-generated code:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;mod &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;DisplayMock &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;fmt&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;MockFn for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;DisplayMock&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;fmt &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;AnswerFn &lt;&#x2F;span&gt;&lt;span&gt;= dyn (
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;u&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; Fn(
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;u &lt;&#x2F;span&gt;&lt;span&gt;crate::Unimock,
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span&gt;core::fmt::Formatter&amp;lt;&amp;#39;_&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;        ) -&amp;gt; core::fmt::Result
&lt;&#x2F;span&gt;&lt;span&gt;    ) + Send + Sync;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The upside is that all mutation patterns are now possible, but the downside is that &lt;code&gt;dyn Fn&lt;&#x2F;code&gt; is a type instead of a bound.&lt;&#x2F;p&gt;
&lt;p&gt;The unimock user has to supply a value of this type into the &lt;code&gt;answers&lt;&#x2F;code&gt; combinator:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; defined as:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;.. {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; note: F::AnswerFn (i.e. dyn Fn) must be an unsized type:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;answers&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;answer_fn&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;static F::&lt;&#x2F;span&gt;&lt;span&gt;AnswerFn) { .. }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; u = Unimock::new(
&lt;&#x2F;span&gt;&lt;span&gt;    DisplayMock::fmt
&lt;&#x2F;span&gt;&lt;span&gt;        .next_call(matching!(_))
&lt;&#x2F;span&gt;&lt;span&gt;        .answers(&amp;amp;|_, f| write!(f, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;mocked!&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This forces the user to pass a function reference rather than any closure that just happens to implement a given &lt;code&gt;Fn&lt;&#x2F;code&gt; signature like it did before.&lt;&#x2F;p&gt;
&lt;p&gt;Closure patterns are possible, and unimock supports this, but not in a generic way.
Closures have to be passed using a different combinator:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;.. {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; must take an Arc, because userland functions
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; can&amp;#39;t accept unsized types:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;answers_arc&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;answer_fn&lt;&#x2F;span&gt;&lt;span&gt;: Arc&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;F::&lt;&#x2F;span&gt;&lt;span&gt;AnswerFn&amp;gt;) { .. }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I of course tried to make an abstraction that unites the two APIs, but failed to do so.
I believe the reason for this is that &lt;em&gt;dyn trait coercion&lt;&#x2F;em&gt; can&#x27;t be abstracted.&lt;&#x2F;p&gt;
&lt;h5 id=&quot;footnotes&quot;&gt;Footnotes&lt;&#x2F;h5&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;For even more background, and a walk-through of Unimock&#x27;s overall design: &lt;a href=&quot;https:&#x2F;&#x2F;audunhalland.github.io&#x2F;blog&#x2F;how-to-write-a-type-level-mock-library-in-rust&#x2F;&quot;&gt;How to write a type-level mock library in Rust&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>How to write a type-level mock library in Rust</title>
        <published>2023-04-11T00:00:00+00:00</published>
        <updated>2023-04-11T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://audunhalland.github.io/blog/how-to-write-a-type-level-mock-library-in-rust/" type="text/html"/>
        <id>https://audunhalland.github.io/blog/how-to-write-a-type-level-mock-library-in-rust/</id>
        
        <content type="html">&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;unimock&#x2F;latest&#x2F;unimock&#x2F;&quot;&gt;Unimock 0.5&lt;&#x2F;a&gt; is just out, and I wanted to reflect on how it came to be, how its design emerged and various implementation challenges along the way.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;why-unimock-exists&quot;&gt;Why unimock exists&lt;&#x2F;h2&gt;
&lt;p&gt;Rust already has a number of mocking solutions, like the popular &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;mockall&#x2F;latest&#x2F;mockall&#x2F;&quot;&gt;mockall&lt;&#x2F;a&gt;. Why another one?&lt;&#x2F;p&gt;
&lt;p&gt;The idea behind unimock comes from the observation that Rust traits form some kind of graph:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; There is a supertrait relationship between Foo and Bar:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Foo&lt;&#x2F;span&gt;&lt;span&gt;: Bar {}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;A &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;B &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; A and B are related via the fact that some type T needs to implement both:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;func&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;t&lt;&#x2F;span&gt;&lt;span&gt;: T) where T: A + B {}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To be maximally flexible, a trait mocking library needs to support all combinations of trait bounds.
If we wanted to write a test implementation of &lt;code&gt;Foo&lt;&#x2F;code&gt;, we&#x27;d also have to write one for &lt;code&gt;Bar&lt;&#x2F;code&gt;.
If we want to test &lt;code&gt;func&lt;&#x2F;code&gt;, the test type needs to implement both &lt;code&gt;A&lt;&#x2F;code&gt; and &lt;code&gt;B&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Ultimately, there is only one possibility: All the traits need to be implemented by &lt;em&gt;the same type&lt;&#x2F;em&gt;!&lt;&#x2F;p&gt;
&lt;p&gt;This challenge first appeared while I experimented with &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;entrait&#x2F;latest&#x2F;entrait&#x2F;&quot;&gt;entrait&lt;&#x2F;a&gt;, which is entirely made up of a trait graph.
I quickly hit a road block when trying to use &lt;code&gt;mockall&lt;&#x2F;code&gt; as a test tool, because it uses one type per mocked trait.
The next sections are modelled as a walkthrough on how a universal Unimock-like mocker can be (and is!) implemented, and some of the design challenges are discussed.&lt;&#x2F;p&gt;
&lt;p&gt;By &lt;em&gt;&amp;quot;type-level&amp;quot; mocker&lt;&#x2F;em&gt;, I mean a library that relies more on generics, traits and bounds than lots of macro-generated custom code blocks.
Unimock, although it comes with a fairly complex procedural macro that does trait parsing and analysis, is a type-level mocker.
The macro&#x27;s job is to figure out what types to define!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;implementing-a-simple-mocker-from-scratch&quot;&gt;Implementing a simple mocker from scratch&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s start with a simple trait.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Foo &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We&#x27;d like to mock it! We want to start out with a type that can return a configurable &lt;code&gt;i32&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Mocker&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Foo for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Mocker &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We&#x27;ve created a simple mock library!
But now let&#x27;s reuse that type for another trait:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Bar &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;bar&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; String;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now the &lt;code&gt;Mocker&lt;&#x2F;code&gt; needs two fields: An &lt;code&gt;i32&lt;&#x2F;code&gt; and a &lt;code&gt;String&lt;&#x2F;code&gt;.
Going on like this can&#x27;t scale forever, so we need to look at some more dynamic solutions.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Mocker &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;return_values&lt;&#x2F;span&gt;&lt;span&gt;: HashMap&amp;lt;TypeId, Box&amp;lt;dyn Any&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Foo for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Mocker &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; ret = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.return_values.get(&amp;amp;TypeId::of::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;()).unwrap();
&lt;&#x2F;span&gt;&lt;span&gt;        ret.downcast_ref::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;().unwrap().clone()
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This looks more dynamic and using &lt;code&gt;Any&lt;&#x2F;code&gt; and &lt;code&gt;TypeId&lt;&#x2F;code&gt; seems like a good idea, but there are two problems:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;All methods that return &lt;code&gt;i32&lt;&#x2F;code&gt; has to return the same value.&lt;&#x2F;li&gt;
&lt;li&gt;All return types need to be &lt;code&gt;&#x27;static&lt;&#x2F;code&gt; in order to implement &lt;code&gt;Any&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;We have to be able to control each trait method individually from any other trait method.
Rust trait methods are not types, and cannot implement any traits (i.e. &lt;code&gt;Any&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;This can be solved by defining a new type per method:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; module which represents the trait
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;mod &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;FooMock &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; struct which represents the method
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And defining each method&#x27;s return type through a new trait with an associated type:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; &amp;#39;static makes this automatically implement Any
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;MockFn&lt;&#x2F;span&gt;&lt;span&gt;: &amp;#39;static {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Output&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;MockFn for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;FooMock&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;foo &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Output &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Mocker &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;return_values&lt;&#x2F;span&gt;&lt;span&gt;: HashMap&amp;lt;TypeId, Box&amp;lt;dyn Any&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Foo for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Mocker &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; return_value = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self
&lt;&#x2F;span&gt;&lt;span&gt;            .return_values
&lt;&#x2F;span&gt;&lt;span&gt;            .get(&amp;amp;TypeId::of::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;FooMock::&lt;&#x2F;span&gt;&lt;span&gt;foo&amp;gt;())
&lt;&#x2F;span&gt;&lt;span&gt;            .unwrap();
&lt;&#x2F;span&gt;&lt;span&gt;        return_value.downcast_ref::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;().unwrap().clone()
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;What&#x27;s the point of the &lt;code&gt;Output&lt;&#x2F;code&gt; associated type? It&#x27;s not used at all in &lt;code&gt;impl Foo for Mocker&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Before the mocker can be used, the user needs to specify which return values each method will have.
It would not be a very good idea if the interface to configure the mocker exposed &lt;code&gt;Box&amp;lt;dyn Any&amp;gt;&lt;&#x2F;code&gt;.
So we&#x27;ll design the configuration API around this associated type, and box the return value internally:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Mocker &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;should_return&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;F: MockFn&amp;gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;value&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;F::&lt;&#x2F;span&gt;&lt;span&gt;Output)
&lt;&#x2F;span&gt;&lt;span&gt;        where &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;F::&lt;&#x2F;span&gt;&lt;span&gt;Output: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;static
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.return_values.insert(TypeId::of::&amp;lt;F&amp;gt;(), Box::new(value));
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we have implemented two phases of the mocking lifecycle: &lt;em&gt;Configuration&lt;&#x2F;em&gt; and &lt;em&gt;interaction&lt;&#x2F;em&gt;.
The two phases are galvanically isolated but still type safe by the use of &lt;code&gt;dyn Any&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;There is still a problem that return values must be &lt;code&gt;&#x27;static&lt;&#x2F;code&gt;.
This can be solved by using an internal &lt;code&gt;enum&lt;&#x2F;code&gt; with two variants:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;A &lt;code&gt;Box&amp;lt;Any&amp;gt;&lt;&#x2F;code&gt; representing a &lt;code&gt;&#x27;static&lt;&#x2F;code&gt; return value&lt;&#x2F;li&gt;
&lt;li&gt;A &lt;code&gt;Box&amp;lt;Any&amp;gt;&lt;&#x2F;code&gt; representing a &lt;em&gt;static closure&lt;&#x2F;em&gt; that returns &lt;code&gt;F::Output&lt;&#x2F;code&gt; directly (and postpone the problem with what it actually references with its non-static lifetime).&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;returning-references&quot;&gt;Returning references&lt;&#x2F;h3&gt;
&lt;p&gt;The return values currently supported are owned types, including &lt;code&gt;&amp;amp;&#x27;static T&lt;&#x2F;code&gt;.
There is no way to put non-static references into that hash map.&lt;&#x2F;p&gt;
&lt;p&gt;What kind of references could we expect to support?
The archetypal pattern is likely some variation of this with the elided self-lifetime:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Foo &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;str&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To support this, the mocker has to store an owned version of the return value and return a reference to it.
This already indicates that the configuration and interaction phases do not necessarily use the same types.
We could configure the mocker with a &lt;code&gt;String&lt;&#x2F;code&gt; and then return a &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt; of it later.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;MockFn &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Output&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Response&lt;&#x2F;span&gt;&lt;span&gt;: AsRef&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is a start, but now &lt;em&gt;all&lt;&#x2F;em&gt; outputs must be references of the response, that is not what we wanted.
What we need is a way to tell the mocker the &amp;quot;general category&amp;quot; of output: Owned or Borrowed.
Let&#x27;s introduce a new trait:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Respond &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Type&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;Type&lt;&#x2F;code&gt; is the owned version of the type that is allowed to be stored in the hash map.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Owned&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt;(PhantomData&amp;lt;T&amp;gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Borrowed&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T: ?Sized + &amp;#39;static&amp;gt;(PhantomData&amp;lt;T&amp;gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;These are the two current variants.
To wire things up, we need yet another trait:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Output&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&amp;#39;a, R: Respond&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Type&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;from_response&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;response&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;R::&lt;&#x2F;span&gt;&lt;span&gt;Type) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Type;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let&#x27;s start by implementing &lt;code&gt;Owned&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; Respond for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Owned&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Type &lt;&#x2F;span&gt;&lt;span&gt;= T;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;, T: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; Output&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Owned&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Type &lt;&#x2F;span&gt;&lt;span&gt;= T;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;from_response&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;response&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;R::&lt;&#x2F;span&gt;&lt;span&gt;Type) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Type {
&lt;&#x2F;span&gt;&lt;span&gt;        response
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;These implementations express that an &lt;code&gt;Output::Type&lt;&#x2F;code&gt; is an &amp;quot;identity transformation&amp;quot; from &lt;code&gt;Respond::Type&lt;&#x2F;code&gt; in the case of &lt;code&gt;Owned&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;.
Notice the &lt;code&gt;&#x27;a&lt;&#x2F;code&gt; lifetime introduced in the &lt;code&gt;Output&lt;&#x2F;code&gt; trait.
This lifetime represents borrowing from the mocker, and we will need it when implementing &lt;code&gt;Borrowed&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;But first, we have to change &lt;code&gt;MockFn&lt;&#x2F;code&gt; to use our new traits, and now we&#x27;ll need a Generic Associated Type:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;MockFn &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Response&lt;&#x2F;span&gt;&lt;span&gt;: Respond;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Output&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;: Output&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Response&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The bounds on these types illustrate how &lt;code&gt;Response&lt;&#x2F;code&gt; and &lt;code&gt;Output&lt;&#x2F;code&gt; are connected.
The output must be an Output that can be constructed from the response, and the output is allowed to be a reference.&lt;&#x2F;p&gt;
&lt;p&gt;Now over to &lt;code&gt;Borrowed&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T: ?&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Sized&lt;&#x2F;span&gt;&lt;span&gt; + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Respond for Borrowed&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Type &lt;&#x2F;span&gt;&lt;span&gt;= Box&amp;lt;dyn std::borrow::Borrow&amp;lt;T&amp;gt; + Send + Sync&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The type stored in the hash map is any type from which we can &lt;code&gt;Borrow&lt;&#x2F;code&gt; a &lt;code&gt;T&lt;&#x2F;code&gt;.
For example, &lt;code&gt;String&lt;&#x2F;code&gt; in the case of &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt;. (If we want &lt;code&gt;Mocker&lt;&#x2F;code&gt; to be thread safe we need Send and Sync bounds.)&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;, T: ?&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Sized&lt;&#x2F;span&gt;&lt;span&gt; + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;static&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Output&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;for Borrowed&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Type &lt;&#x2F;span&gt;&lt;span&gt;= &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt; T;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;from_response&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;response&lt;&#x2F;span&gt;&lt;span&gt;: &amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;as Respond&amp;gt;::Type,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Type {
&lt;&#x2F;span&gt;&lt;span&gt;        panic!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;Dang, cannot return borrow of a local&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here is the next spanner in the works.
We want to borrow the &lt;code&gt;Respond::Type&lt;&#x2F;code&gt;, but can&#x27;t, since it is being passed by-value into the &lt;code&gt;from_response&lt;&#x2F;code&gt; function.
Now you might object that the &lt;code&gt;from_response&lt;&#x2F;code&gt; design is wrong.
Why is it passed an owned response when it could just borrow directly from the mocker&#x27;s hash table?
Some paragraphs ago we said that the hash table can contain one of two things: An owned response and a closure that produces an owned response.
So we need to handle the ephemeral owned response anyway: Yes, returning a reference to something just produced by a function.&lt;&#x2F;p&gt;
&lt;p&gt;Finding a (safe) solution to this problem was not easy.
I needed some kind of data structure that can convert &lt;code&gt;T&lt;&#x2F;code&gt;&#x27;s to &lt;code&gt;&amp;amp;&#x27;self T&lt;&#x2F;code&gt;&#x27;s.
It needs to use interior mutability, or else we can&#x27;t get &lt;code&gt;&amp;amp;T&lt;&#x2F;code&gt;&#x27;s out.
Once a &lt;code&gt;T&lt;&#x2F;code&gt; has been added to the structure, that &lt;code&gt;T&lt;&#x2F;code&gt; can&#x27;t ever be touched until &lt;code&gt;drop&lt;&#x2F;code&gt;, or else the &lt;code&gt;&amp;amp;T&lt;&#x2F;code&gt; would be invalid.
The end solution involves a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;once_cell&#x2F;latest&#x2F;once_cell&#x2F;&quot;&gt;once_cell&lt;&#x2F;a&gt; chain, the code can be found in the unimock repo.&lt;&#x2F;p&gt;
&lt;p&gt;In Unimock, there are even more variants of &lt;code&gt;Respond&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;Output&lt;&#x2F;code&gt;, the most notable one is called &lt;code&gt;Mixed&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;.
&lt;code&gt;Mixed&lt;&#x2F;code&gt; is used in Owned&#x2F;Borrowed tree-like situations, for example with the following signatures:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Foo &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;f1&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Option&amp;lt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;str&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;f2&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; (String, &amp;amp;String);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;observing-parameters&quot;&gt;Observing parameters&lt;&#x2F;h3&gt;
&lt;p&gt;So in addition to outputs, functions also have inputs.&lt;&#x2F;p&gt;
&lt;p&gt;In a typical mocking situation we want to test some code that calls into a trait.
The trait implementation would like to check that it receives some expected parameter value, and react accordingly.
&amp;quot;Reacting accordingly&amp;quot; is to be understood as &amp;quot;returning some specific output&amp;quot;.&lt;&#x2F;p&gt;
&lt;p&gt;This parameter observation business is also something that happens at interaction time, but is specified up front at configuration time.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s extend the &lt;code&gt;MockFn&lt;&#x2F;code&gt; trait with some inputs:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;MockFn &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Inputs&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;&amp;#39;i&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; ..
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When the function has multiple inputs it will use a tuple.
The &lt;code&gt;&#x27;i&lt;&#x2F;code&gt; lifetime is quite handy.
As long as the parameters are immutable, the same lifetime can be used for all of them.
(&lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt; on the other hand, can not be modelled this way. I won&#x27;t get into this in this article, but it&#x27;s related to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;100013&quot;&gt;unexpected higher-ranked lifetime error in GAT usage&lt;&#x2F;a&gt;)&lt;&#x2F;p&gt;
&lt;p&gt;So, the mocker receives some &lt;code&gt;Inputs&lt;&#x2F;code&gt; and wants to produce an &lt;code&gt;Output&lt;&#x2F;code&gt;.
The user has to control which inputs map to which output.
It&#x27;s not possible to just put the inputs in any kind of table, because that would require trait bounds.
Instead the user needs to supply a function that receives a reference to the inputs, and returns whether it is a &amp;quot;match&amp;quot; or not.&lt;&#x2F;p&gt;
&lt;p&gt;Something like:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;|inputs| matches!(inputs, (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;3.0&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This closure type can be converted into to &lt;code&gt;Box&amp;lt;Any&amp;gt;&lt;&#x2F;code&gt; and stored together with the return values in the hash map.&lt;&#x2F;p&gt;
&lt;p&gt;Except, it&#x27;s not that easy.
This solution &amp;quot;works&amp;quot;, but is quite hard to debug when the user &lt;em&gt;expects&lt;&#x2F;em&gt; a match that for some reason doesn&#x27;t at runtime.
The mocker could panic with a message that it found no response for the given inputs, but it would be handy to see &lt;em&gt;why&lt;&#x2F;em&gt; there was a mismatch.
(In mocking terminology, a proper mock is something you &lt;em&gt;expect&lt;&#x2F;em&gt; to be called.
If it isn&#x27;t, that&#x27;s an error.)&lt;&#x2F;p&gt;
&lt;p&gt;Another annoying issue with the &lt;code&gt;matches!&lt;&#x2F;code&gt; approach is the lack of &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust&#x2F;issues&#x2F;87121&quot;&gt;Deref patterns&lt;&#x2F;a&gt;.
I.e. if one of the inputs is of type &lt;code&gt;String&lt;&#x2F;code&gt;, it can&#x27;t be matched with a &lt;code&gt;&amp;quot;string literal&amp;quot;&lt;&#x2F;code&gt;.
This is one of the most annoying missing features in Rust for me personally.
So what I wanted for Unimock was a higher level macro for input matching, that encapsulates the closue syntax (it produces a closure) and has some plumbing that works around some of the missing Deref patterns issues.&lt;&#x2F;p&gt;
&lt;p&gt;The macro is called &lt;code&gt;matching!&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;matching!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;3.0&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It basically expands to a pattern match on the arguments, along with useful diagnostics in the case of an unsuccessful match.
Every string literal is matched using &lt;code&gt;AsRef&amp;lt;str&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The input matching was not the hardest part to design.
Now let&#x27;s move to the part that is most visible to users.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-configuration-phase&quot;&gt;The configuration phase&lt;&#x2F;h2&gt;
&lt;p&gt;The configuration phase is what happens first (at the top of the test) and really ties all the parts toghether.
It&#x27;s also the API that users have to suffer through actually using, API ergonomics should be in the front seat!&lt;&#x2F;p&gt;
&lt;p&gt;First some general observations about the mock configuration phase.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The mocker is either configured or it&#x27;s not configured.
This implies some kind of builder pattern, where you are either in the configuration phase or interaction phase, enforced by type state.&lt;&#x2F;li&gt;
&lt;li&gt;People like to write reusable code. It should be easy to factor out parts of the configuration phase to be reused many times.&lt;&#x2F;li&gt;
&lt;li&gt;It should not be too verbose.&lt;&#x2F;li&gt;
&lt;li&gt;It should not be too cryptic.&lt;&#x2F;li&gt;
&lt;li&gt;Not too much &lt;code&gt;rustfmt&lt;&#x2F;code&gt; indentation whitespace.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;rustfmt&lt;&#x2F;code&gt; indentation should visually group things in a logical way.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Let&#x27;s start with a &lt;code&gt;MockBuilder&lt;&#x2F;code&gt; first:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;MockBuilder::new()
&lt;&#x2F;span&gt;&lt;span&gt;    .add(FooMock::foo)
&lt;&#x2F;span&gt;&lt;span&gt;    .inputs(matching!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;    .returns(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    .next()
&lt;&#x2F;span&gt;&lt;span&gt;    .add(..)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;    .build()
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This API is not that nice because there is no grouped indentation for one &amp;quot;unit of mock&amp;quot;.
It&#x27;s also too verbose for my taste, needing method calls like &lt;code&gt;.add&lt;&#x2F;code&gt; and &lt;code&gt;.inputs&lt;&#x2F;code&gt; which don&#x27;t add information.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s look at defining an API for a &amp;quot;unit of mock&amp;quot; first.
Remember the &lt;code&gt;struct foo&lt;&#x2F;code&gt; inside &lt;code&gt;mod FooMock&lt;&#x2F;code&gt;, the one that implements &lt;code&gt;MockFn&lt;&#x2F;code&gt;.
Let&#x27;s try to put a helper method in &lt;code&gt;MockFn&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;MockFn &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;mock&lt;&#x2F;span&gt;&lt;span&gt;() -&amp;gt; MockFnBuilder { .. }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;FooMock::foo::mock()
&lt;&#x2F;span&gt;&lt;span&gt;    .inputs(matching!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;    .returns(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Even better:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;MockFn &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;mock&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;matching&lt;&#x2F;span&gt;&lt;span&gt;: impl MatchingFn) -&amp;gt; MockFnBuilder&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; { .. }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;FooMock::foo::mock(matching!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;    .returns(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Even better (with the help of &lt;code&gt;rustfmt&lt;&#x2F;code&gt;):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;MockFn &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;mock&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;matching&lt;&#x2F;span&gt;&lt;span&gt;: impl MatchingFn) -&amp;gt; MockFnBuilder&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; { .. }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;FooMock::foo
&lt;&#x2F;span&gt;&lt;span&gt;    .mock(matching!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;    .returns(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Integrating this into the universal mocker builder:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;MockBuilder::new()
&lt;&#x2F;span&gt;&lt;span&gt;    .mock(FooMock::foo
&lt;&#x2F;span&gt;&lt;span&gt;        .mock(matching!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;        .returns(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    )
&lt;&#x2F;span&gt;&lt;span&gt;    .mock(..)
&lt;&#x2F;span&gt;&lt;span&gt;    .build()
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It&#x27;s a bit better than where we started, but not quite there.
I still don&#x27;t like the boilerplate-y &lt;code&gt;.mock&lt;&#x2F;code&gt; (or &lt;code&gt;.add&lt;&#x2F;code&gt;) call that&#x27;s required here.
Also there&#x27;s a &lt;code&gt;.build()&lt;&#x2F;code&gt; call that&#x27;s very Builder Pattern, and really doesn&#x27;t convey anything.&lt;&#x2F;p&gt;
&lt;p&gt;What I&#x27;d like is just &lt;em&gt;one function call&lt;&#x2F;em&gt; with one parameter that just returns the mocker.
This can be done using an array!&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Mocker &lt;&#x2F;span&gt;&lt;span&gt;{ .. }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Mocker &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;new&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;configs&lt;&#x2F;span&gt;&lt;span&gt;: impl IntoIterator&amp;lt;Item = MockFnBuilder&amp;lt;?&amp;gt;&amp;gt;) { .. }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Except that &lt;code&gt;MockFnBuilder&lt;&#x2F;code&gt; has to be a generic type because it needs to operate on the corresponding &lt;code&gt;MockFn&lt;&#x2F;code&gt;&#x27;s &lt;code&gt;Inputs&lt;&#x2F;code&gt; and &lt;code&gt;Response&lt;&#x2F;code&gt; types.&lt;&#x2F;p&gt;
&lt;p&gt;So if we can&#x27;t use that, maybe the &lt;code&gt;MockFnBuilder&amp;lt;F: MockFn&amp;gt;&lt;&#x2F;code&gt; can be converted to a &lt;code&gt;DynMockFnBuilder&lt;&#x2F;code&gt; before being passed to the array?
That would still require one extra line per mock config:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;Mocker::new([
&lt;&#x2F;span&gt;&lt;span&gt;    FooMock::foo
&lt;&#x2F;span&gt;&lt;span&gt;        .mock(matching!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;        .returns(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;        .into_dyn() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; &amp;lt;-- :(
&lt;&#x2F;span&gt;&lt;span&gt;])
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Sometimes I wish that Rust could do implicit type conversion..&lt;&#x2F;p&gt;
&lt;p&gt;But not today.
What&#x27;s nice about the array approach is that the genericity of each &lt;code&gt;MockFnBuilder&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; ends with each &lt;code&gt;.into_dyn()&lt;&#x2F;code&gt;, and the compiler has an easier job because each array item has the same type (it has to!).
The obvious &amp;quot;solution&amp;quot; to missing implicit type conversion is.. &lt;em&gt;tuples&lt;&#x2F;em&gt;.
With tuples we&#x27;ll end up with a big unique type for every unique mock configuration, the compiler will have a harder time, but this is Ergonomic (and elegant) API design!&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;Mocker::new((
&lt;&#x2F;span&gt;&lt;span&gt;    MockFoo::foo
&lt;&#x2F;span&gt;&lt;span&gt;        .mock(matching!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;        .returns(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;    MockBar::bar
&lt;&#x2F;span&gt;&lt;span&gt;        .mock(matching!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;        .returns(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I&#x27;m starting to like this!&lt;&#x2F;p&gt;
&lt;p&gt;Now the problem is the corny grammars: &amp;quot;Mock matching 1 returns 2&amp;quot;.
I think there&#x27;s too much use of the word &amp;quot;mock&amp;quot; everywhere.&lt;&#x2F;p&gt;
&lt;p&gt;To get a hint of what the helper function is going to be called, we can analyze the type-state in the mock builder:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;MockFoo::foo&lt;&#x2F;code&gt; a trait method&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;.mock(matching!(something))&lt;&#x2F;code&gt; describe the function call&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;.returns(something)&lt;&#x2F;code&gt; describe the response&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;After step 2 we have described a function call, so the &amp;quot;keyword&amp;quot; could include the word &amp;quot;call&amp;quot;.
In addition, it would be nice if it sounded as a general rule.
&amp;quot;Each time this function is called with these parameters, it should return this&amp;quot;.
&lt;code&gt;each_call&lt;&#x2F;code&gt; is nice.
We&#x27;ll also support &lt;code&gt;next_call&lt;&#x2F;code&gt; and &lt;code&gt;some_call&lt;&#x2F;code&gt; (the Unimock documentation explains the difference).&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;Mocker::new((
&lt;&#x2F;span&gt;&lt;span&gt;    MockFoo::foo
&lt;&#x2F;span&gt;&lt;span&gt;        .each_call(matching!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;        .returns(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;    MockBar::bar
&lt;&#x2F;span&gt;&lt;span&gt;        .next_call(matching!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;        .returns(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And what about &lt;code&gt;Mocker::new&lt;&#x2F;code&gt;?
It needs to accept a generic with a trait bound as its only parameter.
That trait will be called &lt;code&gt;Clause&lt;&#x2F;code&gt;, and must of course be implemented for tuples of up to N elements.
Using a trait like this makes it easy to factor out common clauses to helper functions.
As long is the trait is implemented for both tuples and the elements inside the tuples, it&#x27;s possible to build arbitrarily deep clause trees.&lt;&#x2F;p&gt;
&lt;p&gt;I think we have a good enough configuration API now, although all the details are not described here.
These are (very roughly) the steps that were taken before the Unimock API ended up the way it looks now.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;mock-the-ecosystem&quot;&gt;Mock the ecosystem!&lt;&#x2F;h2&gt;
&lt;p&gt;Unimock before 0.5 was intended to be used in application development for locally defined traits.
I only recently came to think of rust traits as living inside a big interconnected graph.&lt;&#x2F;p&gt;
&lt;p&gt;So unimock 0.5 introduces mocking of upstream crates from &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;core&#x2F;index.html&quot;&gt;core&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;&quot;&gt;std&lt;&#x2F;a&gt;.
The most notable ones are &lt;code&gt;Display&lt;&#x2F;code&gt;, &lt;code&gt;Debug&lt;&#x2F;code&gt;, &lt;code&gt;Read&lt;&#x2F;code&gt;, &lt;code&gt;Write&lt;&#x2F;code&gt; and &lt;code&gt;Seek&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;I&#x27;m not sure where to to take unimock next.
Should unimock depend on all kinds of third party crates or should it be the other way around?
It&#x27;s not yet clear to me what&#x27;s the ideal solution.&lt;&#x2F;p&gt;
&lt;p&gt;I&#x27;ll close off this post by posting a new fun test case from the repo, demonstrating how &lt;code&gt;Display&lt;&#x2F;code&gt; and &lt;code&gt;Write&lt;&#x2F;code&gt; works:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;use unimock::mock::core::fmt::DisplayMock;
&lt;&#x2F;span&gt;&lt;span&gt;use unimock::mock::std::io::WriteMock;
&lt;&#x2F;span&gt;&lt;span&gt;use unimock::*;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;test&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;test&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; All the clauses here use `next_call`
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; and therefore MUST happen in the specified order:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; mocker = Unimock::new((
&lt;&#x2F;span&gt;&lt;span&gt;        DisplayMock::fmt
&lt;&#x2F;span&gt;&lt;span&gt;            .next_call(matching!())
&lt;&#x2F;span&gt;&lt;span&gt;            .mutates(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;, _| write!(f, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;hello &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;unimock&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)),
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; NOTE: `write!` calls `write_all` which
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; is a default method that implicitly
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; gets re-routed into `write`:
&lt;&#x2F;span&gt;&lt;span&gt;        WriteMock::write
&lt;&#x2F;span&gt;&lt;span&gt;            .next_call(matching!(eq!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;hello &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)))
&lt;&#x2F;span&gt;&lt;span&gt;            .returns(Ok(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;6&lt;&#x2F;span&gt;&lt;span&gt;)),
&lt;&#x2F;span&gt;&lt;span&gt;        WriteMock::write
&lt;&#x2F;span&gt;&lt;span&gt;            .next_call(matching!(eq!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;unimock&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)))
&lt;&#x2F;span&gt;&lt;span&gt;            .returns(Ok(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;uni&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.len())),
&lt;&#x2F;span&gt;&lt;span&gt;        WriteMock::write
&lt;&#x2F;span&gt;&lt;span&gt;            .next_call(matching!(eq!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;mock&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)))
&lt;&#x2F;span&gt;&lt;span&gt;            .returns(Ok(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;mock&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.len())),
&lt;&#x2F;span&gt;&lt;span&gt;    ));
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    write!(&amp;amp;mut mocker.clone(), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;{mocker}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;).unwrap();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Unimock 0.4</title>
        <published>2022-11-27T00:00:00+00:00</published>
        <updated>2022-11-27T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://audunhalland.github.io/blog/unimock-0-4/" type="text/html"/>
        <id>https://audunhalland.github.io/blog/unimock-0-4/</id>
        
        <content type="html">&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;audunhalland&#x2F;unimock&quot;&gt;Unimock&lt;&#x2F;a&gt; (&lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;unimock&#x2F;latest&#x2F;unimock&#x2F;&quot;&gt;docs&lt;&#x2F;a&gt;) is a trait mocking library.
Its defining feature is that all generated mock implementations are implemented for the same type (&lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;unimock&#x2F;latest&#x2F;unimock&#x2F;struct.Unimock.html&quot;&gt;&lt;code&gt;Unimock&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;).
This design allows using a mock object where the type of the generic value is constrained by several trait bounds at the same time (e.g. &lt;code&gt;T: Foo + Bar&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;Other features:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Declarative verification of calls up front (executed at &lt;code&gt;drop&lt;&#x2F;code&gt;-time)&lt;&#x2F;li&gt;
&lt;li&gt;Argument matching through pattern matching or &lt;code&gt;Eq&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Partial mocking (though this needs to be manually integrated with some &amp;quot;canonical implementation&amp;quot;)&lt;&#x2F;li&gt;
&lt;li&gt;Versatile support for different types of return values, including borrowed values&lt;&#x2F;li&gt;
&lt;li&gt;Largely implemented via generics, the macro expansions keep the size of generated code to an absolute minimum&lt;&#x2F;li&gt;
&lt;li&gt;Safe Rust™&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;version-0-4&quot;&gt;Version 0.4&lt;&#x2F;h2&gt;
&lt;p&gt;Version 0.4 contains many improvements.
First and foremost, it introduces more internal traits in order to expose a simpler yet more powerful API to end users.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;mock-construction&quot;&gt;Mock construction&lt;&#x2F;h3&gt;
&lt;p&gt;There is now less boilerplate involved when instantiating a new mock object:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; unimock = Unimock::new((
&lt;&#x2F;span&gt;&lt;span&gt;    FooMock::foo
&lt;&#x2F;span&gt;&lt;span&gt;        .next_call(matching!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;        .returns(Some(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)),
&lt;&#x2F;span&gt;&lt;span&gt;    BarMock::bar
&lt;&#x2F;span&gt;&lt;span&gt;        .next_call(matching!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;        .returns(Ok(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;42&lt;&#x2F;span&gt;&lt;span&gt;)),
&lt;&#x2F;span&gt;&lt;span&gt;));
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;Unimock::new&lt;&#x2F;code&gt; accepts anything that implements &lt;code&gt;Clause&lt;&#x2F;code&gt;, which includes tuples up to 16 elements.
This eliminates the manual type-erasure step needed in version 0.3 (having to call &lt;code&gt;.in_order()&lt;&#x2F;code&gt; on each terminal clause).
There is a tradeoff though: Since the tuple elements all have different types, the compiler has to do more work.
In this case I do think that improved ergonomics are worth it.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;more-versatile-return-types&quot;&gt;More versatile return types&lt;&#x2F;h3&gt;
&lt;p&gt;In version 0.3, it wasn&#x27;t possible to specify an output value for a function returning &lt;code&gt;-&amp;gt; Option&amp;lt;&amp;amp;T&amp;gt;&lt;&#x2F;code&gt;.
This type is really a mix between an outer owned value and an inner borrowed value.&lt;&#x2F;p&gt;
&lt;p&gt;Version 0.4 introduces new abstractions to be able to represent this.
It includes specific support for &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;&#x2F;code&gt; and &lt;code&gt;Result&amp;lt;&amp;amp;T, E&amp;gt;&lt;&#x2F;code&gt;.
The longer term plan is to be able to &lt;code&gt;#[derive]&lt;&#x2F;code&gt; these capabilities for custom user-defined types.&lt;&#x2F;p&gt;
&lt;p&gt;Example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;unimock&lt;&#x2F;span&gt;&lt;span&gt;(api = FooMock)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Foo &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;arg&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;str&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Option&amp;lt;&amp;amp;String&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; u = Unimock::new(
&lt;&#x2F;span&gt;&lt;span&gt;    FooMock::foo
&lt;&#x2F;span&gt;&lt;span&gt;        .next_call(matching!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;        .returns(Some(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_string()))
&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;here, unimock automatically converts the &lt;code&gt;Option&amp;lt;String&amp;gt;&lt;&#x2F;code&gt; into an &lt;code&gt;Option&amp;lt;&amp;amp;String&amp;gt;&lt;&#x2F;code&gt; internally.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;improved-diagnostics-on-matching-failures&quot;&gt;Improved diagnostics on matching! failures&lt;&#x2F;h3&gt;
&lt;p&gt;Unimock will now try to diagnose what exactly went wrong when a mismatch happens.&lt;&#x2F;p&gt;
&lt;p&gt;Example&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;unimock&lt;&#x2F;span&gt;&lt;span&gt;(api = FooMock)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Foo &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;arg&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;str&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; u = Unimock::new(FooMock::foo.next_call(matching!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)).returns(()));
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Unimock as Foo&amp;gt;::foo(&amp;amp;u, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Running this code will produce the following terminal ouput:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;thread &amp;#39;foo::mismatch&amp;#39; panicked at &amp;#39;Foo::foo(&amp;quot;b&amp;quot;): Method invoked in the correct order (1), but inputs didn&amp;#39;t match Foo::foo(&amp;quot;a&amp;quot;) at tests&#x2F;foo.rs:42. 
&lt;&#x2F;span&gt;&lt;span&gt;Pattern mismatch for input #0 (actual &#x2F; expected):
&lt;&#x2F;span&gt;&lt;span&gt;Diff &amp;lt; left &#x2F; right &amp;gt; :
&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&amp;quot;b&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;quot;a&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Except only better:
Unimock uses &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;pretty_assertions&#x2F;latest&#x2F;pretty_assertions&#x2F;&quot;&gt;pretty_assertions&lt;&#x2F;a&gt; to write this diff to the terminal, so diffs are are actually printed with colored output.&lt;&#x2F;p&gt;
&lt;p&gt;Note that the &lt;code&gt;matching!()&lt;&#x2F;code&gt; macro uses pattern matching by default.
Printing a &lt;code&gt;Debug&lt;&#x2F;code&gt;-based diff on a pattern mismatch might not produce a good diff output, since patterns could be much smaller than the actuall value due to spreads or other variations in syntax.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;matching!()&lt;&#x2F;code&gt; now also supports matching using &lt;code&gt;Eq&lt;&#x2F;code&gt;!
Just write &lt;code&gt;matching!(eq!(arg0), eq!(arg1))&lt;&#x2F;code&gt; to match against full values instead of patterns.
If the values implement &lt;code&gt;Debug&lt;&#x2F;code&gt;, you will likely get a high quality diff.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;gats-to-reduce-the-amount-of-generated-code&quot;&gt;GATs to reduce the amount of generated code&lt;&#x2F;h3&gt;
&lt;p&gt;Unimock uses a lot lifetime-generic data type abstractions.
Although these constructs could be expressed in older versions of Rust,
Generic Associated Types allow unimock to be much more compact,
greatly reducing the amount of generated code.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;other-changes&quot;&gt;Other changes&lt;&#x2F;h3&gt;
&lt;p&gt;See the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;audunhalland&#x2F;unimock&#x2F;blob&#x2F;main&#x2F;CHANGELOG.md#040---2022-11-20&quot;&gt;unimock changelog&lt;&#x2F;a&gt; for other changes in 0.4.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-future-of-unimock&quot;&gt;The future of unimock&lt;&#x2F;h2&gt;
&lt;p&gt;I intend to continue to support unimock, and attempt to actively dogfood it for internal projects at work as much as possible.&lt;&#x2F;p&gt;
&lt;p&gt;Unimock is still a project in early development, and I continue to try and find use cases that demonstrate its potential shortcomings.&lt;&#x2F;p&gt;
&lt;p&gt;A very recent experiment I did was to try and generate a mock implementation for &lt;code&gt;std::io::Read&lt;&#x2F;code&gt; (and &lt;code&gt;Write&lt;&#x2F;code&gt;).
There I hit a new roadblock, because of the signature of &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;io&#x2F;trait.Read.html#method.read_vectored&quot;&gt;&lt;code&gt;Read::read_vectored&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;.
In this signature, the object receives&#x2F;borrows a parameter with an internal lifetime bound to &lt;code&gt;&#x27;self&lt;&#x2F;code&gt;.
Unimock&#x27;s traits aren&#x27;t yet able to express this.&lt;&#x2F;p&gt;
&lt;p&gt;Some more upcoming changes to core traits are to be expected, for unimock to be able to work with more interesting function signatures.&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
